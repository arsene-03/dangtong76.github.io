<!DOCTYPE html>
<html lang="en" dir="auto">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=no"
    />
    <meta
      name="description"
      content="Learning Kubernetes [toc] 3. 도커 기본 다지기 3.1 도커 설치하기 3.1.1 Ubuntu 설치 sudo apt-get update sudo apt-get install docker.io sudo ln -sf /usr/bin/docker.i..."
    />
    <meta name="revised" content="ff840bb3691476618fd914e6d360a95225fca8fe" />
    <meta name="author" content="dangtong76" />
    <meta name="generator" content="jekyll-rtd-theme v2.0.10" />
    <meta name="theme-color" content="#2980b9" />
    <title>Learning Kubernetes · 당통의 블로그</title>
    <meta name="twitter:title" content="Learning Kubernetes · 당통의 블로그" />
    <meta
      name="twitter:description"
      content="Learning Kubernetes [toc] 3. 도커 기본 다지기 3.1 도커 설치하기 3.1.1 Ubuntu 설치 sudo apt-get update sudo apt-get install docker.io sudo ln -sf /usr/bin/docker.i..."
    />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@dangtong76" />
    <meta
      name="twitter:url"
      content="http://localhost:4000/kubernetes/Learning-kubernetes.html"
    />
    <meta name="twitter:creator" content="@jekyll-rtd-theme v2.0.10" />
    <meta property="og:title" content="Learning Kubernetes · 당통의 블로그" />
    <meta
      property="og:description"
      content="Learning Kubernetes [toc] 3. 도커 기본 다지기 3.1 도커 설치하기 3.1.1 Ubuntu 설치 sudo apt-get update sudo apt-get install docker.io sudo ln -sf /usr/bin/docker.i..."
    />
    <meta property="og:locale" content="en" />
    <meta
      property="og:url"
      content="http://localhost:4000/kubernetes/Learning-kubernetes.html"
    />
    <meta property="og:type" content="article" />
    <meta property="article:author" content="dangtong76" />
    <meta
      property="article:published_time"
      content="2021-01-07T17:30:40+09:00"
    />
    <meta
      property="article:modified_time"
      content="2021-01-08T00:15:42+09:00"
    />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "http://localhost:4000/kubernetes/Learning-kubernetes.html"
        },
        "headline": "Learning Kubernetes · 당통의 블로그",
        "image": [],
        "author": { "@type": "Person", "name": "dangtong76" },
        "datePublished": "2021-01-07T17:30:40+09:00",
        "dateModified": "2021-01-08T00:15:42+09:00",
        "publisher": {
          "@type": "User",
          "name": "dangtong76",
          "logo": {
            "@type": "ImageObject",
            "url": "https://avatars0.githubusercontent.com/u/24955731?v=4"
          }
        },
        "description": "Learning Kubernetes [toc] 3. 도커 기본 다지기 3.1 도커 설치하기 3.1.1 Ubuntu 설치 sudo apt-get update sudo apt-get install docker.io sudo ln -sf /usr/bin/docker.i..."
      }
    </script>
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" />
    <link
      rel="canonical"
      href="http://localhost:4000/kubernetes/Learning-kubernetes.html"
    />
    <link rel="icon" type="image/svg+xml" href="/assets/images/favicon.svg" />
    <link
      rel="icon"
      type="image/png"
      href="/assets/images/favicon-16x16.png"
      sizes="16x16"
    />
    <link
      rel="icon"
      type="image/png"
      href="/assets/images/favicon-32x32.png"
      sizes="32x32"
    />
    <link
      rel="icon"
      type="image/png"
      href="/assets/images/favicon-96x96.png"
      sizes="96x96"
    />
    <link rel="mask-icon" href="/assets/images/favicon.svg" color="#2980b9" />
    <link
      rel="apple-touch-icon"
      href="/assets/images/apple-touch-icon-300x300.jpg"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/rundocs/jekyll-rtd-theme@2.0.10/assets/css/theme.min.css"
    />
    <script>
      window.ui = {
        title: "당통의 블로그",
        baseurl: "",
        i18n: {
          search_results: "Search Results",
          search_results_found:
            "Search finished, found # page(s) matching the search query.",
          search_results_not_found:
            "Your search did not match any documents, please make sure that all characters are spelled correctly!",
        },
      };
    </script>
  </head>
  <body class="container">
    <div class="sidebar-wrap overflow-hidden">
      <div class="sidebar height-full overflow-y-scroll overflow-x-hidden">
        <div class="header d-flex flex-column p-3 text-center">
          <div class="title pb-1">
            <a
              class="h4 no-underline py-1 px-2 rounded-1"
              href="/"
              title="다양한 기술관련 정리 모음"
            >
              <i class="fa fa-home"></i> 당통의 블로그
            </a>
          </div>
          <span class="version"></span>
          <form
            class="search pt-2"
            action="/search.html"
            method="get"
            autocomplete="off"
          >
            <input
              class="form-control input-block input-sm"
              type="text"
              name="q"
              placeholder="Search docs..."
            />
          </form>
        </div>
        <div
          class="toctree py-2"
          data-spy="affix"
          role="navigation"
          aria-label="main navigation"
        >
          <ul></ul>
          <a
            class="caption d-block text-uppercase no-wrap px-2 py-0"
            href="/kubernetes/"
          >
            쿠버네티스 교재
          </a>
          <ul>
            <li class="toc level-1 current" data-sort="" data-level="1">
              <a
                class="d-flex flex-items-baseline current"
                href="/kubernetes/Learning-kubernetes.html"
                >Learning Kubernetes</a
              >
            </li>
          </ul>
          <a
            class="caption d-block text-uppercase no-wrap px-2 py-0"
            href="/spotfireBasic/"
          >
            Spotfire 교재
          </a>
          <ul>
            <li class="toc level-1" data-sort="" data-level="1">
              <a
                class="d-flex flex-items-baseline"
                href="/spotfireBasic/Spotfire%20Analyst%20User%20Guide.html"
                >Spotfire Analyst 데이터 시각화 첫걸음</a
              >
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content-wrap">
      <div
        class="header d-flex flex-justify-between p-2 hide-lg hide-xl"
        aria-label="top navigation"
      >
        <button
          id="toggle"
          aria-label="Toggle menu"
          class="btn-octicon p-2 m-0 text-white"
          type="button"
        >
          <i class="fa fa-bars"></i>
        </button>
        <div class="title flex-1 d-flex flex-justify-center">
          <a class="h4 no-underline py-1 px-2 rounded-1" href="/"
            >당통의 블로그</a
          >
        </div>
      </div>
      <div class="content p-3 p-sm-5">
        <div class="navigation-top d-flex flex-justify-between">
          <ul
            class="breadcrumb"
            role="navigation"
            aria-label="breadcrumbs navigation"
          >
            <li class="breadcrumb-item">
              <a class="no-underline" href="/" title="/">
                <i class="fa fa-home"></i>
              </a>
            </li>
            <li class="breadcrumb-item">
              <a href="/kubernetes/">kubernetes</a>
            </li>
            <li class="breadcrumb-item" aria-current="page">
              Learning-kubernetes.md
            </li>
          </ul>
          <a
            class="edit"
            href="https://github.com/dangtong76/dangtong76.github.io/edit/gh-pages/kubernetes/Learning-kubernetes.md"
            title="Edit on GitHub"
            rel="noreferrer"
            target="_blank"
          >
            <i class="fa fa-edit"></i>
          </a>
        </div>
        <hr />
        <div
          role="main"
          itemscope="itemscope"
          itemtype="https://schema.org/Article"
        >
          <div class="markdown-body" itemprop="articleBody">
            <h1 id="learning-kubernetes">Learning Kubernetes</h1>
            <p>[toc]</p>
            <h2 id="3-도커-기본-다지기">3. 도커 기본 다지기</h2>
            <h3 id="31-도커-설치하기">3.1 도커 설치하기</h3>
            <h4 id="311-ubuntu-설치">3.1.1 Ubuntu 설치</h4>
            <pre><code class="language-{bash}">sudo apt-get update
sudo apt-get install docker.io
sudo ln -sf /usr/bin/docker.io /usr/local/bin/docker
</code></pre>
            <blockquote>
              <p>
                우분투 패키지 메니저는 apt-get , apt-cache, apt 가 있습니다.
                모두 동일한 명령어라고 보면 되지만, apt 를 쓸경우 일단 글자수가
                적고, 출력 Output 에 색상이 추가되어 좀더 예쁘게 보입니다.
              </p>
            </blockquote>
            <h4 id="312-centos-6">3.1.2 CentOS 6</h4>
            <pre><code class="language-{bash}">sudo yum install http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
sudo yum install docker-io
</code></pre>
            <h4 id="313-centos-7">3.1.3 CentOS 7</h4>
            <pre><code class="language-{bash}">sudo yum install docker
sudo service docker start
sudo chkconfig docker on # 부팅시에 자동 스타트업
</code></pre>
            <h4 id="314-mac-및-windows-에-설치">
              3.1.4 Mac 및 Windows 에 설치
            </h4>
            <p>아래 URL 에서 다운받아 설치 하면 됩니다.</p>
            <p>
              MAC 의 경우 Hyperkit, Windows 의 경우 Hyper-V 를 가상화 레이어로
              사용 합니다.
            </p>
            <p>
              Docker Desktop for Mac :
              https://hub.docker.com/editions/community/docker-ce-desktop-mac/
            </p>
            <p>
              Docker Desktop for Windows :
              https://hub.docker.com/editions/community/docker-ce-desktop-windows/
            </p>
            <h3 id="32-도커-기본-명령어">3.2 도커 기본 명령어</h3>
            <p>도커 파일 내에서 사용 가능한 명령어</p>
            <table>
              <thead>
                <tr>
                  <th>명령</th>
                  <th>설명</th>
                  <th>명령</th>
                  <th>설명</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>FROM</strong></td>
                  <td>베이스 이미지 지정</td>
                  <td><strong>VOLUME</strong></td>
                  <td>볼륨 마운트</td>
                </tr>
                <tr>
                  <td><strong>RUN</strong></td>
                  <td>명령실행</td>
                  <td><strong>USER</strong></td>
                  <td>사용자 지정</td>
                </tr>
                <tr>
                  <td><strong>CMD</strong></td>
                  <td>컨테이너 실행 명령</td>
                  <td><strong>WORKDIR</strong></td>
                  <td>작업 디렉토리</td>
                </tr>
                <tr>
                  <td><strong>LABEL</strong></td>
                  <td>라벨 설정</td>
                  <td><strong>ONBUILD</strong></td>
                  <td>Dockerfile 내의 변수</td>
                </tr>
                <tr>
                  <td><strong>EXPOSE</strong></td>
                  <td>포트 익스포트</td>
                  <td><strong>STOPSIGNAL</strong></td>
                  <td>빌드 완료 후 실행되는 명령</td>
                </tr>
                <tr>
                  <td><strong>ENV</strong></td>
                  <td>환경변수</td>
                  <td><strong>HEALTHCHECK</strong></td>
                  <td>시스템 콜 시그널 설정</td>
                </tr>
                <tr>
                  <td><strong>ADD</strong></td>
                  <td>파일/디렉토리 추가</td>
                  <td><strong>SHELL</strong></td>
                  <td>기본 쉘 설정</td>
                </tr>
                <tr>
                  <td><strong>CPOY</strong></td>
                  <td>파일 복사</td>
                  <td> </td>
                  <td> </td>
                </tr>
                <tr>
                  <td><strong>ENTRYPOINT</strong></td>
                  <td>컨테이너 실행 명령사</td>
                  <td> </td>
                  <td> </td>
                </tr>
              </tbody>
            </table>
            <h4 id="321-도커-hub-사용을-위한-계정생성">
              3.2.1 도커 hub 사용을 위한 계정생성
            </h4>
            <pre><code class="language-{bash}">sudo docker login
</code></pre>
            <blockquote>
              <p>
                <a href="https://hub.docker.com/">docker hub</a>
                (hub.docker.dom) 에 가입 후 명령어를 실행 해야 로그인이 가능
                합니다.
              </p>
            </blockquote>
            <h4 id="322-도커-이미지-검색">3.2.2 도커 이미지 검색</h4>
            <p>search 명령으로 nginx 를 검색해 봅니다.</p>
            <pre><code class="language-{bash}">sudo docker search nginx
</code></pre>
            <p>
              <img
                src="/kubernetes/img/docker_k8s_search.png"
                alt="docker_k8s_search"
              />
            </p>
            <h4 id="323-도커-이미지-다운로드">3.2.3 도커 이미지 다운로드</h4>
            <p>
              nodejs 이미지를 설치해봅니다. 최신 안정버전인 12.14 버전을 설치
              합니다.
            </p>
            <pre><code class="language-{bash}">sudo docker pull nodejs:latest    # 최신버전 다운로드
sudo docker pull nodejs:12.14.0   # 특정버전 다운로드
sudo docker pull -a nodejs        # 모든버전 다운로드
</code></pre>
            <p>
              <img src="/kubernetes/img/dcoker-pull.png" alt="dcoker-pull" />
            </p>
            <h4 id="324-도커-이미지-목록-보기">3.2.4 도커 이미지 목록 보기</h4>
            <pre><code class="language-{bash}">docker image list
docker image ls
docker images
</code></pre>
            <p>
              <img
                src="/kubernetes/img/docker-image-list.png"
                alt="docker-image-list"
              />
            </p>
            <h3 id="33-도커-이미지-생성-하기">3.3 도커 이미지 생성 하기</h3>
            <h4 id="331-서비스를-위한-application-코드-작성">
              3.3.1 서비스를 위한 Application 코드 작성
            </h4>
            <p>
              hostname_finder 라는 폴더를 만들고 그 아래 main.go 및 Dockerfiles
              2개 파일을 작성 합니다.
            </p>
            <p>
              먼저 vi 또는 gedit 를 실행해서 아래 파일을 main.go 라는 이름 으로
              작성 합니다.
            </p>
            <pre><code class="language-{go}">package main

import (
	"fmt"
	"os"
	"log"
	"net/http"
)
func handler(w http.ResponseWriter, r *http.Request){
	name, err := os.Hostname()
	if err != nil {
		panic(err)
	}

	fmt.Fprintln(w,"hostname:", name)
}
func main() {
  fmt.Fprintln(os.Stdout,"Starting GoApp Server......")
	http.HandleFunc("/",handler)
	log.Fatal(http.ListenAndServe(":8080",nil))
}
</code></pre>
            <h4 id="332-이미지-생성을-위한-dockerfile-작성">
              3.3.2 이미지 생성을 위한 Dockerfile 작성
            </h4>
            <pre><code class="language-{dockerfile}">FROM golang:1.11-alpine AS build

WORKDIR /src/
COPY main.go go.* /src/
RUN CGO_ENABLED=0 go build -o /bin/demo

FROM scratch
COPY --from=build /bin/demo /bin/demo
ENTRYPOINT ["/bin/demo"]
</code></pre>
            <h4 id="333-컨테이너-이미지-생성">3.3.3 컨테이너 이미지 생성</h4>
            <p>hostname_finder 라는 폴더 안에서 아래 명령어를 실행 합니다.</p>
            <pre><code class="language-{bash}">docker build -t goapp .
</code></pre>
            <blockquote>
              <p>
                . 은 현재 디렉토리서 Dockerfile 참조해서 first-container 라는
                이미지를 생성 합니다.
              </p>
            </blockquote>
            <p>[출력]</p>
            <pre><code class="language-{text}">Sending build context to Docker daemon  3.072kB
Step 1/7 : FROM golang:1.11-alpine AS build
 ---&gt; e116d2efa2ab
Step 2/7 : WORKDIR /src/
 ---&gt; Using cachedocker
 ---&gt; c3210d8eb11f
Step 3/7 : COPY main.go go.* /src/
 ---&gt; ef55118ea78c
Step 4/7 : RUN CGO_ENABLED=0 go build -o /bin/demo
 ---&gt; Running in e557730bf11c
Removing intermediate container e557730bf11c
 ---&gt; d55bd9bd3f81
Step 5/7 : FROM scratch
 ---&gt;
Step 6/7 : COPY --from=build /bin/demo /bin/demo
 ---&gt; bb4b1250a05e
Step 7/7 : ENTRYPOINT ["/bin/demo"]
 ---&gt; Running in 4419d56988aa
Removing intermediate container 4419d56988aa
 ---&gt; 36f5c919e3b8
Successfully built 36f5c919e3b8
Successfully tagged goapp:latest
</code></pre>
            <p>이미지가 생성 되었는지 명령어를 통해 확인 합니다.</p>
            <pre><code class="language-{bash}">docker images
</code></pre>
            <p>[출력]</p>
            <pre><code class="language-{txt}">REPOSITORY                           TAG                 IMAGE ID            CREATED              SIZE
&lt;none&gt;                               &lt;none&gt;              d55bd9bd3f81        About a minute ago   325MB
goapp                              latest              36f5c919e3b8        About a minute ago   6.51MB
&lt;none&gt;                               &lt;none&gt;              1c688e9c7e3c        3 days ago           325MB
&lt;none&gt;                               &lt;none&gt;              9b60c66a5b82        3 days ago           6.51MB
&lt;none&gt;                               &lt;none&gt;              7fc44021a96f        3 days ago           325MB
&lt;none&gt;                               &lt;none&gt;              2caa0c2ac791        3 days ago           325MB
&lt;none&gt;                               &lt;none&gt;              c46d81105b65        3 days ago           6.51MB
&lt;none&gt;                               &lt;none&gt;              2d78705fb4ae        3 days ago           312MB
</code></pre>
            <h3 id="34-도커-컨테이너-시작-및-서비스-확인">
              3.4 도커 컨테이너 시작 및 서비스 확인
            </h3>
            <h4 id="341-도커-컨테이너-시작">3.4.1 도커 컨테이너 시작</h4>
            <pre><code class="language-{bash}">docker run --name goapp-project -p 8080:8080 -d goapp
docker run -it --name goapp-project -p 8080:8080 -d goapp /bin/bash
</code></pre>
            <blockquote>
              <p>–name : 실행한 도커 컨테이너의 이름 지정</p>
              <p>
                -p : 포트 맵핑 정보 localhost 와 컨테이너 포트를 맵핑 합니다.
              </p>
              <p>
                -d : Docker 컨테이너를 백그라운드로 수행하고 컨테이너 ID를 출력
                합니다.
              </p>
              <p>-i : STDIN 계속 interactive 모드로 유지</p>
            </blockquote>
            <h4 id="342-도커-컨테이스-서비스-확인">
              3.4.2 도커 컨테이스 서비스 확인
            </h4>
            <p>curl 명령어를 통해 정상적인 서비스 수행 여부를 확인 합니다.</p>
            <pre><code class="language-{bash}">curl localhost:8080
</code></pre>
            <p>[출력]</p>
            <pre><code class="language-{txt}">hostname: 96fc3a5eb914
</code></pre>
            <h4 id="343-도커-프로세서-확인">3.4.3 도커 프로세서 확인</h4>
            <pre><code class="language-{bash}">docker ps
</code></pre>
            <p><strong>[출력]</strong></p>
            <pre><code class="language-{txt}">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                    NAMES
96fc3a5eb914        goapp                   "/bin/demo"              43 seconds ago      Up 42 seconds       0.0.0.0:8080-&gt;8080/tcp   goapp-project
</code></pre>
            <h4 id="344-프로세서-상세-정보-출력">
              3.4.4 프로세서 상세 정보 출력
            </h4>
            <pre><code class="language-{bash}">docker inspect goapp-project
</code></pre>
            <p>[출력]</p>
            <pre><code class="language-{txt}">[
    {
        "Id": "96fc3a5eb914c58ed83e088681d53a46188edeaab061ff2de0b9852e9dd276c9",
        "Created": "2020-01-10T04:32:12.269012485Z",
        "Path": "/bin/demo",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 31285,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2020-01-10T04:32:12.902395362Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:36f5c919e3b88f1c991eda67d96e62fe02b763182e44f19fb78b2fc055165f3d",
        "ResolvConfPath": "/var/lib/docker/containers/96fc3a5eb914c58ed83e088681d53a46188edeaab061ff2de0b9852e9dd276c9/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/96fc3a5eb914c58ed83e088681d53a46188edeaab061ff2de0b9852e9dd276c9/hostname",
        "HostsPath": "/var/lib/docker/containers/96fc3a5eb914c58ed83e088681d53a46188edeaab061ff2de0b9852e9dd276c9/hosts",
        "LogPath": "/var/lib/docker/containers/96fc3a5eb914c58ed83e088681d53a46188edeaab061ff2de0b9852e9dd276c9/96fc3a5eb914c58ed83e088681d53a46188edeaab061ff2de0b9852e9dd276c9-json.log",
</code></pre>
            <h4 id="345-docker-컨테이너-접속">3.4.5 Docker 컨테이너 접속</h4>
            <pre><code class="language-{bash}"># docker 컨테이너 접속
docker exec -it goapp-project bash

# docker 외부에서 컨테이너에 명령수행 (ls 명령 수행)
docker exec goapp-project ls
</code></pre>
            <blockquote>
              <p>
                -i 또는 –interactive : STDIN을 오픈한 상태로 인터랙티브 모드상태
              </p>
              <p>-t 또는 –tty : terminal 모드</p>
              <p>
                container 이름이 보이지 않고 ID 만 기본적으로 보입니다. 컨테이너
                이름을 출력하려면 아래 명령어를 수행 하면 됩니다.
              </p>
              <p>docker ps –format ""</p>
            </blockquote>
            <h4 id="346-도커-인스턴스-중단-및-삭제">
              3.4.6 도커 인스턴스 중단 및 삭제
            </h4>
            <pre><code class="language-{bash}">docker stop goapp-project
docker rm goapp-project
</code></pre>
            <h3 id="35-도커-이미지를-도커-허브에-업로드">
              3.5. 도커 이미지를 도커 허브에 업로드
            </h3>
            <h4 id="351-도커-허브양식에-맞게-tag-수정하기">
              3.5.1 도커 허브양식에 맞게 tag 수정하기
            </h4>
            <pre><code class="language-{bash}">docker tag goapp  dangtong/goapp
</code></pre>
            <p>[출력]</p>
            <pre><code class="language-{text}">REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE
dangtong/goapp                       latest              12e9a84d9e23        3 days ago          6.51MB
goapp                                latest              12e9a84d9e23        3 days ago          6.51MB
</code></pre>
            <blockquote>
              <p>
                dangtong/firstapp 과 first-container 의 image ID 가 같은 것을
                확인 할 수 있습니다.
              </p>
              <p>
                사실 하나의 이미지를 서로 다른 TAGID 로 공유 하는 것입니다.
                디스크 공간이 늘어나지 않습니다.
              </p>
            </blockquote>
            <h4 id="352-도커-허브에-이미지-업로드-하기">
              3.5.2 도커 허브에 이미지 업로드 하기
            </h4>
            <pre><code class="language-{bash}">docker login --username dangtong
docker push dangtong/goapp
</code></pre>
            <p>[출력]</p>
            <pre><code class="language-{text}">The push refers to repository [docker.io/dangtong/goapp]
cc282a374c26: Pushed
latest: digest: sha256:b18b5ff03599893a7361feda054ebe26de61a71f019dc8725bb33d87f2115968 size: 528
</code></pre>
            <p>
              도커 허브에 로그인 하게 되면 아래와 같이 goapp 이미지가 업로드
              된것을 확인 할 수 있습니다. 이제 인터넷만 연결 되면 어디서는
              자신이 만든 이미지로 컨테이너를 실행 할 수 있습니다.
            </p>
            <p>
              <img
                src="/kubernetes/img/image-20200110124234902.png"
                alt="image-20200110124234902"
              />
            </p>
            <h4 id="353-도커-허브의-이미지로-컨테이너-실행">
              3.5.3 도커 허브의 이미지로 컨테이너 실행
            </h4>
            <p>docker hub 에 있는 이미지를 로딩하여 컨테이너 생성</p>
            <pre><code class="language-{bash}">docker run --name goapp-project -p 8080:8080 -d dangtong/goapp
</code></pre>
            <pre><code class="language-{bash}">docker ps
</code></pre>
            <p>[출력]</p>
            <pre><code class="language-{txt}">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                    NAMES
0938068f8709        dangtong/goapp          "/bin/demo"              5 seconds ago       Up 4 seconds        0.0.0.0:8080-&gt;8080/tcp   goapp-project
</code></pre>
            <p>현재 서비스에 접속하여 확인</p>
            <pre><code class="language-{bash}">curl http://localhost:8080
</code></pre>
            <pre><code class="language-{txt}">hostname: 0938068f8709
</code></pre>
            <h3 id="exercise-1">[Exercise #1]</h3>
            <ol>
              <li>
                <p>서버 호스트명을 출력하는 node.js 프로그램을 만드세요</p>
              </li>
              <li>
                <p>
                  해당 소스로 node 버전 7 기반으로 서비스 하는 Docker file을
                  만들고 이미지를 build 하세요
                </p>
              </li>
              <li>
                <p>
                  tag 명령을 이용해서 docker hub 에 올릴수 있도록 이름을
                  바꾸세요
                </p>
              </li>
              <li>
                <p>
                  docker login 후에 docker hub 에 업로드하여 실제 업로드가
                  되었는지 확인하세요
                </p>
              </li>
            </ol>
            <p>이름은 username/nodejs-app 으로 하세요</p>
            <ul>
              <li>node.js 프로그램 (app.js)</li>
            </ul>
            <pre><code class="language-{javascript}">const http = require('http');
const os = require('os');

console.log("Learning Kubernetes server starting...");

var handler = function(request, response) {
  console.log("Received request from " + request.connection.remoteAddress);
  response.writeHead(200);
  response.end("You've hit " + os.hostname() + "\n");
};

var www = http.createServer(handler);
www.listen(8080);
</code></pre>
            <ul>
              <li>Dcokerfile</li>
            </ul>
            <pre><code class="language-{bash}"># FROM 으로 BASE 이미지 로드
FROM node:7

# ADD 명령어로 이미지에 app.js 파일 추가
ADD app.js /app.js

# ENTRYPOINT 명령어로 node 를 실행하고 매개변수로 app.js 를 전달
ENTRYPOINT ["node", "app.js"]
</code></pre>
            <h2 id="4-쿠버네티스-간단하게-맛보기">
              4. 쿠버네티스 간단하게 맛보기
            </h2>
            <h3 id="41-도커-허브-이미지로-컨테이너-생성-및-확인">
              4.1 도커 허브 이미지로 컨테이너 생성 및 확인
            </h3>
            <ul>
              <li>
                <p>컨테이너 생성 : run/v1 으로 수행 합니다.</p>
                <pre><code class="language-{bash}"># POD 및 Replication Controller 생성 (향후 버전에서 deprecated 될 예정)
$ kubectl run goapp-project --image=dangtong/goapp --port=8080 --generator=run/v1
# POD 만 생성
$ kubectl run goapp-project --image=dangtong/goapp --port=8080 --generator=run-pod/v1
</code></pre>
                <blockquote>
                  <p>
                    generator 를 run/v1 으로 수행 할 경우 내부적으로
                    goapp-project-{random-String} 이라는 컨테이너를 만들면서
                    goapp-project- 이름의 replication controller 도 생기게
                    됩니다.
                  </p>
                </blockquote>
                <ul>
                  <li>
                    Generator 의 종류 : <strong>run-pod/v1</strong> 외에 모두
                    deprecated 될 예정
                  </li>
                </ul>
                <table>
                  <thead>
                    <tr>
                      <th style="text-align: left">Resource</th>
                      <th style="text-align: left">API group</th>
                      <th style="text-align: left">kubectl command</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td style="text-align: left">Pod</td>
                      <td style="text-align: left">v1</td>
                      <td style="text-align: left">
                        <code
                          class="language-plaintext highlighter-rouge notranslate"
                          >kubectl run --generator=run-pod/v1</code
                        >
                      </td>
                    </tr>
                    <tr>
                      <td style="text-align: left">
                        ReplicationController <em>(deprecated)</em>
                      </td>
                      <td style="text-align: left">v1</td>
                      <td style="text-align: left">
                        <code
                          class="language-plaintext highlighter-rouge notranslate"
                          >kubectl run --generator=run/v1</code
                        >
                      </td>
                    </tr>
                    <tr>
                      <td style="text-align: left">
                        Deployment <em>(deprecated)</em>
                      </td>
                      <td style="text-align: left">extensions/v1beta1</td>
                      <td style="text-align: left">
                        <code
                          class="language-plaintext highlighter-rouge notranslate"
                          >kubectl run --generator=deployment/v1beta1</code
                        >
                      </td>
                    </tr>
                    <tr>
                      <td style="text-align: left">
                        Deployment <em>(deprecated)</em>
                      </td>
                      <td style="text-align: left">apps/v1beta1</td>
                      <td style="text-align: left">
                        <code
                          class="language-plaintext highlighter-rouge notranslate"
                          >kubectl run --generator=deployment/apps.v1beta1</code
                        >
                      </td>
                    </tr>
                    <tr>
                      <td style="text-align: left">
                        Job <em>(deprecated)</em>
                      </td>
                      <td style="text-align: left">batch/v1</td>
                      <td style="text-align: left">
                        <code
                          class="language-plaintext highlighter-rouge notranslate"
                          >kubectl run --generator=job/v1</code
                        >
                      </td>
                    </tr>
                    <tr>
                      <td style="text-align: left">
                        CronJob <em>(deprecated)</em>
                      </td>
                      <td style="text-align: left">batch/v2alpha1</td>
                      <td style="text-align: left">
                        <code
                          class="language-plaintext highlighter-rouge notranslate"
                          >kubectl run --generator=cronjob/v2alpha1</code
                        >
                      </td>
                    </tr>
                    <tr>
                      <td style="text-align: left">
                        CronJob <em>(deprecated)</em>
                      </td>
                      <td style="text-align: left">batch/v1beta1</td>
                      <td style="text-align: left">
                        <code
                          class="language-plaintext highlighter-rouge notranslate"
                          >kubectl run --generator=cronjob/v1beta1</code
                        >
                      </td>
                    </tr>
                  </tbody>
                </table>
              </li>
              <li>
                <p>컨테이너 확인</p>
                <pre><code class="language-{bash}">$ kubectl get pods
$ kubectl get rc
</code></pre>
                <pre><code class="language-{text}">$ kubectl get pods
NAME             READY   STATUS    RESTARTS   AGE
goapp-project-bcv5q   1/1     Running   0          2m26s

$ kubectl get rc
NAME            DESIRED   CURRENT   READY   AGE
goapp-project   1         1         1       8m58s
</code></pre>
                <blockquote>
                  <p>아래 명령어를 추가적으로 수행해 보세요</p>
                  <div class="language-plaintext highlighter-rouge notranslate">
                    <div class="highlight">
                      <pre class="highlight"><code>kubectl get pods -o wide
kubectl describe pod goapp-project-bcv5q
</code></pre>
                    </div>
                  </div>
                </blockquote>
              </li>
              <li>
                <p>k8s 서비스 생성</p>
                <pre><code class="language-{bash}">$ kubectl expose rc goapp-project --type=LoadBalancer --name goapp-http
</code></pre>
                <pre><code class="language-{text}">service/firstapp-http exposed
</code></pre>
              </li>
              <li>
                <p>생성한 서비스 조회</p>
                <pre><code class="language-{bash}">$ kubectl get services
</code></pre>
                <pre><code class="language-{text}">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
goapp-http   LoadBalancer   10.96.225.172   &lt;pending&gt;     8080:31585/TCP   104s
kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          14d
</code></pre>
              </li>
              <li>
                <p>서비스 테스트 (여러번 수행)</p>
                <pre><code class="language-{bash}">curl http://10.96.225.172:8080
</code></pre>
                <p>[출력]</p>
                <pre><code class="language-{text}">hostname: goapp-project-bcv5q
hostname: goapp-project-bcv5q
hostname: goapp-project-bcv5q
hostname: goapp-project-bcv5q
</code></pre>
              </li>
              <li>
                <p>replication controller 를 통한 scale-out 수행</p>
                <pre><code class="language-{bash}">kubectl scale rc goapp-project --replicas=3
</code></pre>
                <p>[출력]</p>
                <pre><code class="language-{txt}">replicationcontroller/goapp-project scaled
</code></pre>
              </li>
              <li>
                <p>Scale-Out 결과 확인</p>
                <pre><code class="language-{bash}">kubectl get pod
</code></pre>
                <p>[출력]</p>
                <pre><code class="language-{txt}">NAME                  READY   STATUS    RESTARTS   AGE
goapp-project-bcv5q   1/1     Running   0          16m
goapp-project-c8hml   1/1     Running   0          26s
goapp-project-r7kx5   1/1     Running   0          26s
</code></pre>
              </li>
              <li>
                <p>서비스 테스트 (여러번 수행)</p>
                <pre><code class="language-{bash}">curl http://10.96.225.172:8080
</code></pre>
                <p>[출력]</p>
                <pre><code class="language-{txt}">NAME                  READY   STATUS    RESTARTS   AGE
goapp-project-bcv5q   1/1     Running   0          16m
goapp-project-c8hml   1/1     Running   0          26s
goapp-project-r7kx5   1/1     Running   0          26s
</code></pre>
              </li>
              <li><p>POD 삭제</p></li>
            </ul>
            <p>
              Replication Controller 를 통해 생성된 POD 는 개별 POD 가 삭제 되지
              않습니다. Replication Controller 자체를 삭제 해야 합니다.
            </p>
            <pre><code class="language-{bash}">kubectl delete rc goapp-project
</code></pre>
            <h2 id="5-pods">5. PODS</h2>
            <h3 id="51-pod-기본">5.1 POD 기본</h3>
            <h3 id="51-pod-설정을-yaml-파일로-가져오기">
              5.1 POD 설정을 yaml 파일로 가져오기
            </h3>
            <pre><code class="language-{bash}">kubectl get pod goapp-project-bcv5q -o yaml
kubectl get po goapp-project-bcv5q -o json
</code></pre>
            <p>
              크게 <strong>metadata, spec, status</strong> 항목으로 나누어
              집니다.
            </p>
            <p>[출력 - yaml]</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: "2020-01-10T07:37:49Z"
  generateName: goapp-project-
  labels:
    run: goapp-project
  name: goapp-project-bcv5q
  namespace: default
  ownerReferences:
  - apiVersion: v1
    blockOwnerDeletion: true
    controller: true
    kind: ReplicationController
    name: goapp-project
    uid: e223237f-17e2-44f4-aaee-07e8ff4592b2
  resourceVersion: "3082141"
  selfLink: /api/v1/namespaces/default/pods/goapp-project-bcv5q
  uid: 72bebcbd-8e6e-4906-9f66-1c3821fa49ec
spec:
  containers:
  - image: dangtong/goapp
    imagePullPolicy: Always
    name: goapp-project
    ports:
    - containerPort: 8080
      protocol: TCP
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: default-token-qz4fh
      readOnly: true
  dnsPolicy: ClusterFirst
  enableServiceLinks: true
  nodeName: worker01.sas.com
  priority: 0
  restartPolicy: Always
  schedulerName: default-scheduler
  securityContext: {}
  serviceAccount: default
  serviceAccountName: default
  terminationGracePeriodSeconds: 30
  tolerations:
  - effect: NoExecute
    key: node.kubernetes.io/not-ready
    operator: Exists
    tolerationSeconds: 300
  - effect: NoExecute
    key: node.kubernetes.io/unreachable
    operator: Exists
    tolerationSeconds: 300
  volumes:
  - name: default-token-qz4fh
    secret:
      defaultMode: 420
      secretName: default-token-qz4fh
status:
  conditions:
  - lastProbeTime: null
    lastTransitionTime: "2020-01-10T07:37:49Z"
    status: "True"
    type: Initialized
  - lastProbeTime: null
    lastTransitionTime: "2020-01-10T07:37:55Z"
    status: "True"
    type: Ready
  - lastProbeTime: null
    lastTransitionTime: "2020-01-10T07:37:55Z"
    status: "True"
    type: ContainersReady
  - lastProbeTime: null
    lastTransitionTime: "2020-01-10T07:37:49Z"
    status: "True"
    type: PodScheduled
  containerStatuses:
  - containerID: docker://de3418e51fea7f7a19e7b1d6ff5a4a6f386f337578838e6f1ec0589275ca6f48
    image: dangtong/goapp:latest
    imageID: docker-pullable://dangtong/goapp@sha256:e5872256539152aecd2a8fb1f079e132a6a8f247c7a2295f0946ce2005e36d05
    lastState: {}
    name: goapp-project
    ready: true
    restartCount: 0
    started: true
    state:
      running:
        startedAt: "2020-01-10T07:37:55Z"
  hostIP: 192.168.56.103
  phase: Running
  podIP: 10.40.0.2
  podIPs:
  - ip: 10.40.0.2
  qosClass: BestEffort
  startTime: "2020-01-10T07:37:49Z"
</code></pre>
            <p>###5.2 POD 생성을 위한 YAML 파일 만들기</p>
            <p>아래와 같이 goapp.yaml 파일을 만듭니다.</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: goapp-pod
spec:
  containers:
  - image: dangtong/goapp
    name: goapp-container
    ports:
    - containerPort: 8080
      protocol: TCP
</code></pre>
            <blockquote>
              <p>
                ports 정보를 yaml 파일에 기록 하지 않으면 아래 명령어로 향후에
                포트를 할당해도 됩니다.
              </p>
              <div class="language-plaintext highlighter-rouge notranslate">
                <div class="highlight">
                  <pre
                    class="highlight"
                  ><code>kubectl port-forward goapp-pod 8080:8080
</code></pre>
                </div>
              </div>
            </blockquote>
            <h3 id="53-yaml-파일을-이용한-pod-생성-및-확인">
              5.3 YAML 파일을 이용한 POD 생성 및 확인
            </h3>
            <pre><code class="language-{bash}">$ kubectl create -f goapp.yaml
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}"> pod/goapp-pod created
</code></pre>
            <pre><code class="language-{bash}">$ kubectl get pod
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME                  READY   STATUS    RESTARTS   AGE
goapp-pod             1/1     Running   0          12m
goapp-project-bcv5q   1/1     Running   0          41m
goapp-project-c8hml   1/1     Running   0          25m
goapp-project-r7kx5   1/1     Running   0          25m
</code></pre>
            <h3 id="54-pod-및-container-로그-확인">
              5.4 POD 및 Container 로그 확인
            </h3>
            <ul>
              <li>POD 로그 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl logs goapp-pod
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{bash}">Starting GoApp Server......
</code></pre>
            <ul>
              <li>Container 로그 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl logs goapp-pod -c goapp-container
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{bash}">Starting GoApp Server......
</code></pre>
            <blockquote>
              <p>
                현재 1개 POD 내에 Container 가 1이기 때문에 출력 결과는 동일
                합니다. POD 내의 Container 가 여러개 일 경우 모든 컨테이너의
                표준 출력이 화면에 출력됩니다.
              </p>
            </blockquote>
            <h3 id="exercise-2">[Exercise #2]</h3>
            <ol>
              <li>
                Yaml 파일로 nginx 11.1 버전기반의 이미지를 사용해 nginx-app
                이라는 이름의 Pod 를 만드세요(port : 8080)
              </li>
              <li>curl 명령어르 사용해. Nginx 서비스에 접속</li>
              <li>nginx Pod 의 정보를 yaml 파일로 출력 하세요</li>
              <li>nginx-app Pod 를 삭제 하세요</li>
            </ol>
            <h2 id="6-lable">6. Lable</h2>
            <h3 id="61-lable-정보를-추가해서-pod-생성하기">
              6.1 Lable 정보를 추가해서 POD 생성하기
            </h3>
            <ul>
              <li>
                goapp-with-lable.yaml 이라 파일에 아래 내용을 추가 하여 작성
                합니다.
              </li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: goapp-pod2
  labels:
    env: prod
spec:
  containers:
  - image: dangtong/goapp
    name: goapp-container
    ports:
    - containerPort: 8080
      protocol: TCP
</code></pre>
            <ul>
              <li>yaml 파일을 이용해 pod 를 생성 합니다.</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl create -f ./goapp-with-lable.yaml
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">pod/goapp-pod2 created
</code></pre>
            <ul>
              <li>생성된 POD를 조회 합니다.</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get po --show-labels
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME                  READY   STATUS    RESTARTS   AGE     LABELS
goapp-pod             1/1     Running   0          160m    &lt;none&gt;
goapp-pod2            1/1     Running   0          3m53s   env=prod
goapp-project-bcv5q   1/1     Running   0          9h      run=goapp-project
goapp-project-c8hml   1/1     Running   0          9h      run=goapp-project
goapp-project-r7kx5   1/1     Running   0          9h      run=goapp-project
</code></pre>
            <ul>
              <li>Lable 태그를 출력 화면에 컬럼을 분리해서 출력</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get pod -L env
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME                  READY   STATUS    RESTARTS   AGE     ENV
goapp-pod             1/1     Running   0          161m
goapp-pod2            1/1     Running   0          5m19s   prod
goapp-project-bcv5q   1/1     Running   0          9h
goapp-project-c8hml   1/1     Running   0          9h
goapp-project-r7kx5   1/1     Running   0          9h
</code></pre>
            <ul>
              <li>Lable을 이용한 필터링 조회</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get pod -l env=prod
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME         READY   STATUS    RESTARTS   AGE
goapp-pod2   1/1     Running   0          39h
</code></pre>
            <ul>
              <li>Label 추가 하기</li>
            </ul>
            <pre><code class="language-{bash}">kubectl label pod goapp-pod2 app="application" tier="frondEnd"
</code></pre>
            <ul>
              <li>Label 삭제 하기</li>
            </ul>
            <pre><code class="language-{bash}">kubectl label pod goapp-pod2 app- tier-
</code></pre>
            <h3 id="62-label-셀렉터-사용">6.2 Label 셀렉터 사용</h3>
            <ul>
              <li>AND 연산</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get po -l 'app in (application), tier in (frontEnd)'
</code></pre>
            <ul>
              <li>OR 연산</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get po -l 'app in (application,backEnd)'

kubectl get po -l 'app in (application,frontEnd)'
</code></pre>
            <h3 id="63-생성된-pod-로-부터-yaml-파일-얻기">
              6.3 생성된 POD 로 부터 yaml 파일 얻기
            </h3>
            <pre><code class="language-{bash}">kubectl get pod goapp-pod -o yaml
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: "2020-01-10T08:07:04Z"
  name: goapp-pod
  namespace: default
  resourceVersion: "3086366"
  selfLink: /api/v1/namespaces/default/pods/goapp-pod
  uid: 18cf0ed0-be56-4b54-869c-4473117800b1
spec:
  containers:
  - image: dangtong/goapp
    imagePullPolicy: Always
    name: goapp-container
    ports:
    - containerPort: 8080
      protocol: TCP
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: default-token-qz4fh
      readOnly: true
  dnsPolicy: ClusterFirst
  enableServiceLinks: true
  nodeName: worker02.sas.com
  priority: 0
  restartPolicy: Always
  schedulerName: default-scheduler
  securityContext: {}
  serviceAccount: default
  serviceAccountName: default
  terminationGracePeriodSeconds: 30
  tolerations:
  - effect: NoExecute
    key: node.kubernetes.io/not-ready
    operator: Exists
    tolerationSeconds: 300
  - effect: NoExecute
    key: node.kubernetes.io/unreachable
    operator: Exists
    tolerationSeconds: 300
  volumes:
  - name: default-token-qz4fh
    secret:
      defaultMode: 420
      secretName: default-token-qz4fh
status:
  conditions:
  - lastProbeTime: null
    lastTransitionTime: "2020-01-10T08:07:04Z"
    status: "True"
    type: Initialized
  - lastProbeTime: null
    lastTransitionTime: "2020-01-10T08:07:09Z"
    status: "True"
    type: Ready
  - lastProbeTime: null
    lastTransitionTime: "2020-01-10T08:07:09Z"
    status: "True"
    type: ContainersReady
  - lastProbeTime: null
    lastTransitionTime: "2020-01-10T08:07:04Z"
    status: "True"
    type: PodScheduled
  containerStatuses:
  - containerID: docker://d76af359c556c60d3ac1957d7498513f42ace14998c763456190274a3e4a1d5e
    image: dangtong/goapp:latest
    imageID: docker-pullable://dangtong/goapp@sha256:e5872256539152aecd2a8fb1f079e132a6a8f247c7a2295f0946ce2005e36d05
    lastState: {}
    name: goapp-container
    ready: true
    restartCount: 0
    started: true
    state:
      running:
        startedAt: "2020-01-10T08:07:08Z"
  hostIP: 10.0.2.5
  phase: Running
  podIP: 10.32.0.4
  podIPs:
  - ip: 10.32.0.4
  qosClass: BestEffort
  startTime: "2020-01-10T08:07:04Z"
</code></pre>
            <h3 id="64-lable을-이용한-pod-스케줄링">
              6.4 Lable을 이용한 POD 스케줄링
            </h3>
            <ul>
              <li>노드목록 조회</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get nodes
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME               STATUS   ROLES    AGE   VERSION
master.sas.com     Ready    master   16d   v1.17.0
worker01.sas.com   Ready    &lt;none&gt;   16d   v1.17.0
worker02.sas.com   Ready    &lt;none&gt;   16d   v1.17.0
</code></pre>
            <ul>
              <li>특정 노드에 레이블 부여</li>
            </ul>
            <pre><code class="language-{bash}">kubectl label node worker02.sas.com memsize=high
</code></pre>
            <ul>
              <li>레이블 조회 필터 사용하여 조회</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get nodes -l memsize=high
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME               STATUS   ROLES    AGE   VERSION
worker02.sas.com   Ready    &lt;none&gt;   17d   v1.17.0
</code></pre>
            <ul>
              <li>
                <p>특정 노드에 신규 POD 스케줄링</p>
                <p>
                  아래 내용과 같이 goapp-label-node.yaml 파을을 작성 합니다.
                </p>
              </li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: goapp-pod-memhigh
spec:
  nodeSelector:
    memsize: "high"
  containers:
  - image: dangtong/goapp
    name: goapp-container-memhigh
</code></pre>
            <ul>
              <li>YAML 파일을 이용한 POD 스케줄링</li>
            </ul>
            <pre><code class="language-{bash}">kubectl create -f ./goapp-lable-node.yaml
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">pod/goapp-pod-memhigh created
</code></pre>
            <ul>
              <li>생성된 노드 조회</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get pod -o wide
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME                  READY   STATUS    RESTARTS   AGE    IP          NODE               NOMINATED NODE   READINESS GATES
goapp-pod-memhigh     1/1     Running   0          17s    10.32.0.5   worker02.sas.com   &lt;none&gt;           &lt;none&gt;
</code></pre>
            <h2 id="7-annotation">7. Annotation</h2>
            <h3 id="71-pod-에-annotation-추가하기">
              7.1 POD 에 Annotation 추가하기
            </h3>
            <pre><code class="language-{bash}">kubectl annotate pod goapp-pod-memhigh maker="dangtong" team="k8s-team"
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">pod/goapp-pod-memhigh annotated
</code></pre>
            <h3 id="72-annotation-확인하기">7.2 Annotation 확인하기</h3>
            <ul>
              <li>YAML 파일을 통해 확인하기</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get po goapp-pod-memhigh -o yaml
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">kind: Pod
metadata:
  annotations:
    maker: dangtong
    team: k8s-team
  creationTimestamp: "2020-01-12T15:25:05Z"
  name: goapp-pod-memhigh
  namespace: default
  resourceVersion: "3562877"
  selfLink: /api/v1/namespaces/default/pods/goapp-pod-memhigh
  uid: a12c35d7-d0e6-4c01-b607-cccd267e39ec
spec:
  containers:
</code></pre>
            <ul>
              <li>DESCRIBE 를 통해 확인하기</li>
            </ul>
            <pre><code class="language-{bash}">kubectl describe pod goapp-pod-memhigh
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">Name:         goapp-pod-memhigh
Namespace:    default
Priority:     0
Node:         worker02.sas.com/10.0.2.5
Start Time:   Mon, 13 Jan 2020 00:25:05 +0900
Labels:       &lt;none&gt;
Annotations:  maker: dangtong
              team: k8s-team
Status:       Running
IP:           10.32.0.5
</code></pre>
            <h3 id="73-annotation-삭제">7.3 Annotation 삭제</h3>
            <pre><code class="language-{bash}">kubectl annotate pod  goapp-pod-memhigh maker- team-
</code></pre>
            <h3 id="exercise-3">[[Exercise #3]]</h3>
            <ul>
              <li>
                bitnami/apache 이미지로 Pod 를 만들고 tier=FronEnd, app=apache
                라벨 정보를 포함하세요
              </li>
              <li>Pod 정보를 출력 할때 라벨을 함께 출력 하세요</li>
              <li>app=apache 라벨틀 가진 Pod 만 조회 하세요</li>
              <li>만들어진 Pod에 env=dev 라는 라벨 정보를 추가 하세요</li>
              <li>created_by=kevin 이라는 Annotation을 추가 하세요</li>
              <li>apache Pod를 삭제 하세요</li>
            </ul>
            <h2 id="8-namespace">8. Namespace</h2>
            <h3 id="81-네임스페이스-조회">8.1 네임스페이스 조회</h3>
            <pre><code class="language-{bash}">kubectl get namespace
</code></pre>
            <blockquote><p>kubectl get ns 와 동일함</p></blockquote>
            <p>[output]</p>
            <pre><code class="language-{bash}">NAME              STATUS   AGE
default           Active   17d
kube-node-lease   Active   17d
kube-public       Active   17d
kube-system       Active   17d
</code></pre>
            <h3 id="82-특정-네임스페이스의-pod-조회">
              8.2 특정 네임스페이스의 POD 조회
            </h3>
            <pre><code class="language-{bash}">kubectl get pod --namespace kube-system
# kubectl get po -n kube-system
</code></pre>
            <blockquote>
              <p>kubectl get pod -n kube-system 과 동일함</p>
            </blockquote>
            <p>[output]</p>
            <pre><code class="language-{txt}">coredns-6955765f44-glcdc                 1/1     Running   0          17d
coredns-6955765f44-h7fbb                 1/1     Running   0          17d
etcd-master.sas.com                      1/1     Running   1          17d
kube-apiserver-master.sas.com            1/1     Running   1          17d
kube-controller-manager-master.sas.com   1/1     Running   1          17d
kube-proxy-gm44f                         1/1     Running   1          17d
kube-proxy-ngqr6                         1/1     Running   0          17d
kube-proxy-wmq7d                         1/1     Running   0          17d
kube-scheduler-master.sas.com            1/1     Running   1          17d
weave-net-2pm2x                          2/2     Running   0          17d
weave-net-4wksv                          2/2     Running   0          17d
weave-net-7j7mn                          2/2     Running   0          17d
</code></pre>
            <p>###8.3 YAML 파일을 이용한 네임스페이스 생성</p>
            <ul>
              <li>YAML 파일 작성 : first-namespace.yaml 이름으로 파일 작성</li>
            </ul>
            <pre><code class="language-{bash}">apiVersion: v1
kind: Namespace
metadata:
  name: first-namespace
</code></pre>
            <ul>
              <li>YAML 파일을 이용한 네이스페이스 생성</li>
            </ul>
            <pre><code class="language-{bash}">kubectl create -f first-namespace.yaml
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">namespace/first-namespace created
</code></pre>
            <ul>
              <li>생성된 네임스페이스 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get namespace
kubectl get ns
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME              STATUS   AGE
default           Active   17d
first-namespace   Active   5s
kube-node-lease   Active   17d
kube-public       Active   17d
kube-system       Active   17d
</code></pre>
            <blockquote>
              <p>kubectl create namespace first-namespace 와 동일 합니다.</p>
            </blockquote>
            <h3 id="84-특정-네임스페이스에-pod-생성">
              8.4 특정 네임스페이스에 POD 생성
            </h3>
            <ul>
              <li>first-namespace 에 goapp 생성</li>
            </ul>
            <pre><code class="language-{bash}">kubectl create -f goapp.yaml -n first-namespace
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">pod/goapp-pod created
</code></pre>
            <ul>
              <li>생성된 POD 확인하기</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get pod -n first-namespace
</code></pre>
            <p>[output]</p>
            <pre><code class="language-{txt}">NAME        READY   STATUS    RESTARTS   AGE
goapp-pod   1/1     Running   0          12h
</code></pre>
            <p>###8.5 POD 삭제</p>
            <pre><code class="language-{bash}">'kubectl' delete pod goapp-pod-memhigh
</code></pre>
            <pre><code class="language-{bash}">kubectl delete pod goapp-pod
</code></pre>
            <pre><code class="language-{bash}">kubectl delete pod goapp-pod -n first-namespace
</code></pre>
            <blockquote>
              <p>
                현재 네임스페이스 에서 존재 하는 모든 리소스를 삭제하는 명령은
                아래와 같습니다.
              </p>
              <p>kubectl delete all –all</p>
              <p>
                현재 네임스페이스를 설정하고 조회 하는 명령은 아래와 같습니다.
              </p>
              <div class="language-shell highlighter-rouge notranslate">
                <div class="highlight">
                  <pre
                    class="highlight"
                  ><code><span class="c"># 네임스페이스 설정</span>
kubectl config set-context <span class="nt">--current</span> <span class="nt">--namespace</span><span class="o">=</span>&lt;insert-namespace-name-here&gt;
<span class="c"># 확인</span>
kubectl config view <span class="nt">--minify</span> | <span class="nb">grep </span>namespace:
</code></pre>
                </div>
              </div>
            </blockquote>
            <h3 id="exercise-4">[[Exercise #4]]</h3>
            <ol>
              <li>
                <p>쿠버네티스 클러스터에 몇개의 네임스페이가 존재 하나요?</p>
              </li>
              <li>
                <p>my-dev 라는 네임스페이를 생성하고 nginx Pod를 배포 하세요</p>
              </li>
            </ol>
            <h2 id="9-kubectl-기본-사용법">9. kubectl 기본 사용법</h2>
            <h3 id="91-단축형-키워드-사용하기">9.1 단축형 키워드 사용하기</h3>
            <pre><code class="language-{bash}">kubectl get po			# PODs
kubectl get svc			# Service
kubectl get rc			# Replication Controller
kubectl get deploy	# Deployment
kubectl get ns			# Namespace
kubectl get no			# Node
kubectl get cm			# Configmap
kubectl get pv			# PersistentVolumns
</code></pre>
            <h3 id="92-도움말-보기">9.2 도움말 보기</h3>
            <pre><code class="language-{bash}">kubectl -h
</code></pre>
            <pre><code class="language-{txt}">kubectl controls the Kubernetes cluster manager.

 Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/

Basic Commands (Beginner):
  create         Create a resource from a file or from stdin.
  expose         Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service
  run            Run a particular image on the cluster
  set            Set specific features on objects

Basic Commands (Intermediate):
  explain        Documentation of resources
  get            Display one or many resources
  edit           Edit a resource on the server
  delete         Delete resources by filenames, stdin, resources and names, or by resources and label selector

Deploy Commands:
</code></pre>
            <pre><code class="language-{bash}">kubectl get -h
</code></pre>
            <pre><code class="language-{txt}">Display one or many resources

 Prints a table of the most important information about the specified resources. You can filter the list using a label
selector and the --selector flag. If the desired resource type is namespaced you will only see results in your current
namespace unless you pass --all-namespaces.

 Uninitialized objects are not shown unless --include-uninitialized is passed.

 By specifying the output as 'template' and providing a Go template as the value of the --template flag, you can filter
the attributes of the fetched resources.

Use "kubectl api-resources" for a complete list of supported resources.

Examples:
  # List all pods in ps output format.
  kubectl get pods

  # List all pods in ps output format with more information (such as node name).
  kubectl get pods -o wide

</code></pre>
            <h3 id="93-리소스-정의에-대한-도움말">
              9.3 리소스 정의에 대한 도움말
            </h3>
            <pre><code class="language-{bash}">kubectl explain pods
</code></pre>
            <pre><code class="language-{txt}">KIND:     Pod
VERSION:  v1

DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.

FIELDS:
   apiVersion	&lt;string&gt;
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources

   kind	&lt;string&gt;
     Kind is a string value representing the REST resource this object
     represents. Servers may infer this from the endpoint the client submits
     requests to. Cannot be updated. In CamelCase. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds

   metadata	&lt;Object&gt;
     Standard object's metadata. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata

   spec	&lt;Object&gt;
     Specification of the desired behavior of the pod. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

   status	&lt;Object&gt;
     Most recently observed status of the pod. This data may not be up to date.
     Populated by the system. Read-only. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
</code></pre>
            <h3 id="94-리소스-감시하기">9.4 리소스 감시하기</h3>
            <ul>
              <li>
                Kube-system 네임스페이스에 있는 모든 pod에 대해 모니터링 합니다.
              </li>
            </ul>
            <pre><code class="language-{bash}">kubectl get pods --watch -n kube-system
</code></pre>
            <pre><code class="language-{txt}">root@master:~# k get pods --watch -n kube-system
NAME                                     READY   STATUS    RESTARTS   AGE
coredns-6955765f44-glcdc                 1/1     Running   0          19d
coredns-6955765f44-h7fbb                 1/1     Running   0          19d
etcd-master.sas.com                      1/1     Running   1          19d
kube-apiserver-master.sas.com            1/1     Running   1          19d
kube-controller-manager-master.sas.com   1/1     Running   1          19d
kube-proxy-gm44f                         1/1     Running   1          19d
kube-proxy-ngqr6                         1/1     Running   0          19d
kube-proxy-wmq7d                         1/1     Running   0          19d
kube-scheduler-master.sas.com            1/1     Running   1          19d
weave-net-2pm2x                          2/2     Running   0          19d
weave-net-4wksv                          2/2     Running   0          19d
weave-net-7j7mn                          2/2     Running   0          19d
...
</code></pre>
            <h3 id="95-리소스-비교하기">9.5 리소스 비교하기</h3>
            <pre><code class="language-{bash}">kubectl diff -f goapp.yaml
</code></pre>
            <h3 id="96-kubectx-및-kubens-사용하기">
              9.6 kubectx 및 kubens 사용하기
            </h3>
            <p>
              현재 컨텍스트 및 네임스페이스를 확인하고 전환 할때 손쉽게 사용
              할수 있는 도구
            </p>
            <h4 id="961-kubectx-및-kubens-설치">
              9.6.1 kubectx 및 kubens 설치
            </h4>
            <pre><code class="language-{bash}">git clone https://github.com/ahmetb/kubectx.git ~/.kubectx
COMPDIR=$(pkg-config --variable=completionsdir bash-completion)
ln -sf ~/.kubectx/completion/kubens.bash $COMPDIR/kubens
ln -sf ~/.kubectx/completion/kubectx.bash $COMPDIR/kubectx
cat &lt;&lt; FOE &gt;&gt; ~/.bashrc


#kubectx and kubens
export PATH=~/.kubectx:\$PATH
FOE
</code></pre>
            <h4 id="962-kubectx-및-kubens-사용">
              9.6.2 kubectx 및 kubens 사용
            </h4>
            <ul>
              <li>kubectx 사용</li>
            </ul>
            <pre><code class="language-{bash}">kubectx
kubectx &lt;변경하고 싶은 컨텍스트 이름&gt;
</code></pre>
            <ul>
              <li>kubens 사용</li>
            </ul>
            <p>
              현재 사용중인 네임스페이스를 조회 합니다. 현재 사용중인
              네이스페이스는 하이라이트 됩니다.
            </p>
            <pre><code class="language-{bash}">kubens
</code></pre>
            <pre><code class="language-{txt}">default
first-namespace
kube-node-lease
kube-public
kube-system
</code></pre>
            <p>Kube-system 네이스페이스로 전환 해봅니다.</p>
            <pre><code class="language-{bash}">kubens kube-system
</code></pre>
            <pre><code class="language-{txt}">Context "kubernetes-admin@kubernetes" modified.
Active namespace is "kube-system".
</code></pre>
            <p>
              pod 조회 명령을 내리면 아래와 같이 kube-system 네임스페이스의 pod
              들이 조회 됩니다.
            </p>
            <pre><code class="language-{bash}">kubectl get po
</code></pre>
            <pre><code class="language-{bash}">NAME                                     READY   STATUS    RESTARTS   AGE
coredns-6955765f44-glcdc                 1/1     Running   0          34d
coredns-6955765f44-h7fbb                 1/1     Running   0          34d
etcd-master.sas.com                      1/1     Running   1          34d
kube-apiserver-master.sas.com            1/1     Running   1          34d
kube-controller-manager-master.sas.com   1/1     Running   1          34d
kube-proxy-gm44f                         1/1     Running   1          34d
kube-proxy-ngqr6                         1/1     Running   0          34d
kube-proxy-wmq7d                         1/1     Running   0          34d
kube-scheduler-master.sas.com            1/1     Running   1          34d
weave-net-2pm2x                          2/2     Running   0          34d
weave-net-4wksv                          2/2     Running   0          34d
weave-net-7j7mn                          2/2     Running   0          34d
</code></pre>
            <h3 id="97-kubernetes-컨텍스트-및-네임스페이스-표시하기">
              9.7 kubernetes 컨텍스트 및 네임스페이스 표시하기
            </h3>
            <p>
              kube-ps1을 다운로드 하여 /usr/local/kube-ps1 설치 하고 .bashrc
              파일에 아래와 같이 설정 합니다.
              <a href="https://github.com/jonmosco/kube-ps1">링크</a>
            </p>
            <pre><code class="language-{bash}">source /usr/local/kube-ps1/kube-ps1.sh
PS1='[\u@\h \W $(kube_ps1)]\$ '
</code></pre>
            <pre><code class="language-{bash}">[root@master ~ (⎈ |kubernetes-admin@kubernetes:kube-public)]#
</code></pre>
            <h2 id="10-liveness-probes">10. Liveness probes</h2>
            <p>
              liveness prove는 Pod에 지정된 주소에 Health Check 를 수행하고
              실패할 경우 Pod를 다시 시작 합니다.
            </p>
            <p>
              이때 중요한 점은 단순히 다시 시작만 하는 것이 아니라, 리포지토리로
              부터 이미지를 다시 받아 Pod 를 다시 시작 합니다.
            </p>
            <p>아래 내용으로.</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-http
spec:
  containers:
  - name: liveness
    image: k8s.gcr.io/liveness
    args:
    - /server
    livenessProbe:
      httpGet:
        path: /healthz
        port: 8080
        httpHeaders:
        - name: Custom-Header
          value: Awesome
      initialDelaySeconds: 3
      periodSeconds: 3
</code></pre>
            <p>
              K8s.gcr.io/liveness 이미지는 liveness 테스트를 위해 만들어진
              이미지 입니다. Go 언어로 작성 되었으며, 처음 10초 동안은 정상적인
              서비스를 하지만, 10초 후에는 에러를 발생 시킵니다. 자세한 사항은
              <a
                href="https://github.com/kubernetes/kubernetes/blob/master/test/images/agnhost/liveness/server.go"
                >URL</a
              >
              을 참고 하세요
            </p>
            <h3 id="101-pod-생성">10.1 Pod 생성</h3>
            <pre><code class="language-{bash}">kubectl create -f ./liveness-probe-pod.yaml
</code></pre>
            <p>###10.2 Pod 확인</p>
            <pre><code class="language-{bash}">kubectl get pod
</code></pre>
            <p>아래</p>
            <pre><code class="language-{txt}">NAME            READY   STATUS    RESTARTS   AGE
liveness-http   1/1     Running   0          5s

NAME            READY   STATUS    RESTARTS   AGE
liveness-http   1/1     Running   1          26s

NAME            READY   STATUS    RESTARTS   AGE
liveness-http   1/1     Running   3          68s

NAME            READY   STATUS             RESTARTS   AGE
liveness-http   0/1     CrashLoopBackOff   3          81s

NAME            READY   STATUS             RESTARTS   AGE
liveness-http   0/1     CrashLoopBackOff   5          2m50s
</code></pre>
            <h3 id="103-pod-로그-이벤트-확인">10.3 Pod 로그 이벤트 확인</h3>
            <pre><code class="language-{bash}">kubectl describe pod liveness-http
</code></pre>
            <pre><code class="language-{txt}">Name:         liveness-http
Namespace:    default
Priority:     0
Node:         worker02.acorn.com/192.168.56.110
Start Time:   Wed, 01 Apr 2020 05:54:29 +0000
Labels:       test=liveness
Annotations:  &lt;none&gt;
Status:       Running
IP:           10.36.0.1
IPs:
  IP:  10.36.0.1
Containers:
  liveness:
    Container ID:  docker://0f1ba830b830d5879fe99776cd0db5f3678bf52a11e3ccb1a1e9c65460957817
    Image:         k8s.gcr.io/liveness
    Image ID:      docker-pullable://k8s.gcr.io/liveness@sha256:1aef943db82cf1370d0504a51061fb082b4d351171b304ad194f6297c0bb726a
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Args:
      /server
    State:          Running
      Started:      Wed, 01 Apr 2020 06:01:15 +0000
    Last State:     Terminated
      Reason:       Error
      Exit Code:    2
      Started:      Wed, 01 Apr 2020 05:58:16 +0000
      Finished:     Wed, 01 Apr 2020 05:58:32 +0000
    Ready:          True
    Restart Count:  7
    Liveness:       http-get http://:8080/healthz delay=3s timeout=1s period=3s #success=1 #failure=3
    Environment:    &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-zshgs (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  default-token-zshgs:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-zshgs
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &lt;none&gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type     Reason     Age                    From                         Message
  ----     ------     ----                   ----                         -------
  Normal   Scheduled  &lt;unknown&gt;              default-scheduler            Successfully assigned default/liveness-http to worker02.acorn.com
  Normal   Pulled     6m14s (x3 over 6m53s)  kubelet, worker02.acorn.com  Successfully pulled image "k8s.gcr.io/liveness"
  Normal   Created    6m14s (x3 over 6m52s)  kubelet, worker02.acorn.com  Created container liveness
  Normal   Started    6m14s (x3 over 6m52s)  kubelet, worker02.acorn.com  Started container liveness
  Normal   Pulling    5m55s (x4 over 6m54s)  kubelet, worker02.acorn.com  Pulling image "k8s.gcr.io/liveness"
  Warning  Unhealthy  5m55s (x9 over 6m40s)  kubelet, worker02.acorn.com  Liveness probe failed: HTTP probe failed with statuscode: 500
  Normal   Killing    5m55s (x3 over 6m34s)  kubelet, worker02.acorn.com  Container liveness failed liveness probe, will be restarted
  Warning  BackOff    108s (x17 over 5m36s)  kubelet, worker02.acorn.com  Back-off restarting failed container
</code></pre>
            <p>
              로그이벤트를 보면 Liveness Probe 가 실패해서 컨테이너를 재가동
              하는 메시지가 보입니다.
            </p>
            <p>
              뿐만아니라, 재가동 시에서 Pull image 를 통해 이미지를 다시 가져
              와서 재가동 시키는 것을 볼 수 있습니다.
            </p>
            <h2 id="11-replication-controller">11. Replication Controller</h2>
            <h3 id="111-replication-controller-생성">
              11.1 Replication Controller 생성
            </h3>
            <p>아래와 같이 template를 작성합니다.</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: ReplicationController
metadata:
  name: goapp-rc
spec:
  replicas: 3
  selector:
    app: goapp
  template:
    metadata:
      name: goapp-pod
      labels:
        tier: forntend
        app: goapp
        env: prod
        priority:  high
    spec:
      containers:
      - name: goapp-container
        image: dangtong/goapp
        ports:
        - containerPort: 8080
</code></pre>
            <h3 id="112-pod-생성">11.2 Pod 생성</h3>
            <pre><code class="language-{bash}">kubectl create -f ./rc-goapp.yaml
</code></pre>
            <h3 id="113-pod-생성-확인">11.3 Pod 생성 확인</h3>
            <pre><code class="language-{bash}">kubectl get po

NAME             READY   STATUS    RESTARTS   AGE
goapp-rc-9q689   1/1     Running   0          39s
goapp-rc-d5rnf   1/1     Running   0          39s
goapp-rc-fm7kr   1/1     Running   0          39s
</code></pre>
            <h3 id="114-replication-controller-확인">
              11.4 Replication Controller 확인
            </h3>
            <pre><code class="language-{bash}">kubectl get rc

NAME       DESIRED   CURRENT   READY   AGE
goapp-rc   3         3         3       58s

kubectl get rc -o wide

NAME       DESIRED   CURRENT   READY   AGE   CONTAINERS        IMAGES           SELECTOR
goapp-rc   3         3         3       72s   goapp-container   dangtong/goapp   app=goapp

</code></pre>
            <h3 id="115-특정-pod-삭제하고-변화-확인하기">
              11.5 특정 Pod 삭제하고 변화 확인하기
            </h3>
            <p>아래와 같이 3개의 Pod 중에 하나를 선택해서 삭제 합니다.</p>
            <pre><code class="language-{bash}">kubectl deleete pod goapp-rc-9q689
</code></pre>
            <pre><code class="language-{bash}">kubectl get pod

NAME             READY   STATUS    						RESTARTS   AGE
goapp-rc-d5rnf   1/1     Running   						0          2m
goapp-rc-fm7kr   1/1     Running   						0          2m
goapp-rc-szv2r   1/1     ContainerCreating   	0          6s
</code></pre>
            <p>
              기존 컨테이너를 Terminating 하고 새로운 컨테이너를 생성하는 것을
              볼 수 있습니다.
            </p>
            <h3 id="116-pod-정보를-라벨과-함께-출력해보기">
              11.6 Pod 정보를 라벨과 함께 출력해보기
            </h3>
            <pre><code class="language-{bash}">kubectl get pod --show-labels

NAME             READY   STATUS    RESTARTS   AGE     LABELS
goapp-rc-d5rnf   1/1     Running   0          7m26s   app=goapp
goapp-rc-fm7kr   1/1     Running   0          7m26s   app=goapp
goapp-rc-szv2r   1/1     Running   0          4m51s   app=goapp
</code></pre>
            <h3 id="117-pod-라벨을-변경해보기">11.7 Pod 라벨을 변경해보기</h3>
            <p>
              기존 "app=nginx" 라는 label 을 "app=goapp-exit" 로 변경 합니다.
            </p>
            <pre><code class="language-{bash}">kubectl label pod goapp-rc-szv2r app=goapp-exit --overwrite
</code></pre>
            <p>아래와 같이 pod 를 조회 해봅니다.</p>
            <pre><code class="language-{bash}">kubectl get po

NAME             READY   STATUS              RESTARTS   AGE
goapp-rc-d5rnf   1/1     Running             0          8m49s
goapp-rc-fm7kr   1/1     Running             0          8m49s
goapp-rc-mmn2b   0/1     ContainerCreating   0          5s
goapp-rc-szv2r   1/1     Running             0          6m14s
</code></pre>
            <p>
              기존 3개의 Pod 중 하나의 Label을 변경하면 기존 app=goapp 에는
              2개의 Pod 만 남기 때문에 Replication Controller 는
              <strong>추가적으로 하나의 Pod 를 생성</strong> 합니다.
            </p>
            <pre><code class="language-{bash}">NAME             READY   STATUS    RESTARTS   AGE     LABELS
goapp-rc-d5rnf   1/1     Running   0          9m27s   app=goapp
goapp-rc-fm7kr   1/1     Running   0          9m27s   app=goapp
goapp-rc-mmn2b   1/1     Running   0          43s     app=goapp
goapp-rc-szv2r   1/1     Running   0          6m52s   app=goapp-exit
</code></pre>
            <h3 id="118-pod-template-변경-해보기">
              11.8 Pod Template 변경 해보기
            </h3>
            <p>
              아래와 같이 Pod Template의 spec ➢ spec ➢ containers ➢ image 항목을
              dangtong/goapp-v2 로 변경 합니다.
            </p>
            <pre><code class="language-{bash}">kubectl edit rc nginx
</code></pre>
            <pre><code class="language-{yaml}"># Please edit the object below. Lines beginning with a '#' will be ignored,
# and an empty file will abort the edit. If an error occurs while saving this file will be
# reopened with the relevant failures.
#
apiVersion: v1
kind: ReplicationController
metadata:
  creationTimestamp: "2020-04-01T09:32:23Z"
  generation: 1
  labels:
    app: goapp
  name: goapp-rc
  namespace: default
  resourceVersion: "405444"
  selfLink: /api/v1/namespaces/default/replicationcontrollers/goapp-rc
  uid: 17198300-d964-4de6-a160-825a7a9c16bf
spec:
  replicas: 3
  selector:
    app: goapp
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: goapp
      name: goapp-pod
    spec:
      containers:
      - image: dangtong/goapp-v2 # 이부분을 변경 합닏다.(기존 : dangtong/goapp)
        imagePullPolicy: Always
        name: goapp-container
        ports:
        - containerPort: 80
          protocol: TCP
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
status:
  availableReplicas: 3
  fullyLabeledReplicas: 3
  observedGeneration: 1
  readyReplicas: 3
  replicas: 3
</code></pre>
            <p>저장후 편집기를 종료 합니다.</p>
            <blockquote>
              <p>
                리눅스 편집기에는 다양한 종유가 있습니다. 만약 기본 편집기를
                변경하고 싶으면
              </p>
              <p>
                KUBE_EDITOR="/bin/nano" 를 $HOME/.bashrc 파일에 선언 해주면
                원하는 편집기를 사용 할수 있습니다.
              </p>
            </blockquote>
            <p>###11.9 Pod Template 를 적용하기 위해 임의의 Pod 삭제하기</p>
            <pre><code class="language-{bash}">kubectl get pod

goapp-rc-mvw57   1/1     Running   0          3h6m    10.36.0.2   worker02.acorn.com
goapp-rc-qkrpw   1/1     Running   0          6m26s   10.32.0.2   worker01.acorn.com
goapp-rc-x6q4d   1/1     Running   0          3h6m    10.36.0.1   worker02.acorn.com
</code></pre>
            <p>Pod 삭제</p>
            <pre><code class="language-{bash}">kubectl delete pod goapp-rc-mvw57

pod "goapp-rc-mvw57" deleted
</code></pre>
            <p>Pod 확인</p>
            <pre><code class="language-{bash}">kubectl get pod

NAME             READY   STATUS              RESTARTS   AGE
goapp-rc-bf2xk   0/1     ContainerCreating   0          8s
goapp-rc-qkrpw   1/1     Running             0          7m5s
goapp-rc-x6q4d   1/1     Running             0          3h7m

kubectl get pod -o wide

NAME             READY   STATUS    RESTARTS   AGE     IP          NODE                 NOMINATED NODE   READINESS GATES
goapp-rc-bf2xk   1/1     Running   0          21s     10.32.0.3   worker01.acorn.com
goapp-rc-qkrpw   1/1     Running   0          7m18s   10.32.0.2   worker01.acorn.com
goapp-rc-x6q4d   1/1     Running   0          3h7m    10.36.0.1   worker02.acorn.com
</code></pre>
            <p>접속 해보기</p>
            <pre><code class="language-{bash}"># dangtong/goapp
curl http://10.32.0.2:8080
hostname: goapp-rc-qkrpw

# dangtong/goapp-v3
curl http://10.32.0.3:8080
hostname: goapp-rc-bf2xk
version: goapp-v2
</code></pre>
            <p>###11.10 Pod 스케일링</p>
            <ul>
              <li>
                <p>Template 변경을 통한 스케일링</p>
                <p>
                  아래와 같이 goapp-rc 를 edit 명령으로 수정 합니다. (replicas
                  항목을 3에서 4로 수정)
                </p>
              </li>
            </ul>
            <pre><code class="language-{bash}">정kubectl edit rc goapp-rc
</code></pre>
            <pre><code class="language-{yaml}"># Please edit the object below. Lines beginning with a '#' will be ignored,
# and an empty file will abort the edit. If an error occurs while saving this file will be
# reopened with the relevant failures.
#
apiVersion: v1
kind: ReplicationController
metadata:
  creationTimestamp: "2020-04-01T09:51:49Z"
  generation: 3
  labels:
    app: goapp
  name: goapp-rc
  namespace: default
  resourceVersion: "416408"
  selfLink: /api/v1/namespaces/default/replicationcontrollers/goapp-rc
  uid: 23f58f51-88ab-4828-9a76-cde8a646fff4
spec:
  replicas: 4  # 이부분을 변경 합니다. (기존 : 3)
  selector:
    app: goapp
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: goapp
      name: goapp-pod
    spec:
      containers:
      - image: dangtong/goapp-v2
        imagePullPolicy: Always
        name: goapp-container
        ports:
</code></pre>
            <p>저장 한다음 Pod 및 RC 확인</p>
            <pre><code class="language-{bash}">kubectl get pod

NAME             READY   STATUS              RESTARTS   AGE
goapp-rc-bf2xk   1/1     Running             0          19m
goapp-rc-mr6kb   0/1     ContainerCreating   0          7s
goapp-rc-qkrpw   1/1     Running             0          26m
goapp-rc-x6q4d   1/1     Running             0          3h26m
</code></pre>
            <pre><code class="language-{bash}">kubectl get rc

NAME       DESIRED   CURRENT   READY   AGE
goapp-rc   4         4         4       4h17m
</code></pre>
            <ul>
              <li>명령어를 통한 스케일링</li>
            </ul>
            <p>명령어를 이용해서 스케일링을 수행 할 수 있습니다.</p>
            <pre><code class="language-{bash}">kubectl scale rc goapp-rc --replicas=5
</code></pre>
            <p>실제로 Pod 가 늘어 났는지 확인해봅니다.</p>
            <pre><code class="language-{bash}">kubectl get pod

NAME             READY   STATUS              RESTARTS   AGE
goapp-rc-bf2xk   1/1     Running             0          72m
goapp-rc-dlgfc   0/1     ContainerCreating   0          4s
goapp-rc-mr6kb   1/1     Running             0          53m
goapp-rc-qkrpw   1/1     Running             0          79m
goapp-rc-x6q4d   1/1     Running             0          4h19m
</code></pre>
            <p>###11.11 Replication Controller 삭제</p>
            <p>Replication Controller 와 POD 모두 삭제</p>
            <pre><code class="language-{bash}">kubectl delete rc goapp-rc
</code></pre>
            <p>Replication Controller 만 삭제. POD 는 그대로 유지 합니다.</p>
            <pre><code class="language-{bash}">kubectl delete rc goapp-rc --cascade=false
</code></pre>
            <h2 id="12replicaset">12.ReplicaSet</h2>
            <h3 id="121-rs-생성">12.1 RS 생성</h3>
            <p>
              Selector 를 작성 할때 <strong>ForntEnd</strong> 이고
              <strong>운영계</strong> 이면서 중요도가 <strong>High</strong> 인
              POD 에 대해 RS 를 생성 합니다.
            </p>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
    matchExpressions:
      - {key: env, operator: In, values: [prod]}
      - {key: priority, operator: NotIn, values: [low]}
  template:
    metadata:
      labels:
        tier: frontend
        env: prod
        priority: high
    spec:
      containers:
      - name: php-redis
        image: gcr.io/google_samples/gb-frontend:v3
</code></pre>
            <h3 id="122-rs-확인">12.2 RS 확인</h3>
            <pre><code class="language-{bash}">$ kubectl get pod -o wide

NAME             READY   STATUS    RESTARTS   AGE   IP          NODE
frontend-bstms   1/1     Running   0          53s   10.32.2.7   gke-gke1-default-pool-ad44d907-cq8j
frontend-d4znb   1/1     Running   0          53s   10.32.2.9   gke-gke1-default-pool-ad44d907-cq8j
frontend-rv9bl   1/1     Running   0          53s   10.32.2.8   gke-gke1-default-pool-ad44d907-cq8j
</code></pre>
            <pre><code class="language-{bash}">$ kubectl get rs -o wide

AME             READY   STATUS    RESTARTS   AGE   IP          NODE
frontend-bstms   1/1     Running   0          68s   10.32.2.7   gke-gke1-default-pool-ad44d907-cq8j
frontend-d4znb   1/1     Running   0          68s   10.32.2.9   gke-gke1-default-pool-ad44d907-cq8j
frontend-rv9bl   1/1     Running   0          68s   10.32.2.8   gke-gke1-default-pool-ad44d907-cq8j

</code></pre>
            <pre><code class="language-{bash}">$ kubectl get pod --show-labels

NAME             READY   STATUS    RESTARTS   AGE    LABELS
frontend-bstms   1/1     Running   0          107s   env=prod,priority=high,tier=frontend
frontend-d4znb   1/1     Running   0          107s   env=prod,priority=high,tier=frontend
frontend-rv9bl   1/1     Running   0          107s   env=prod,priority=high,tier=frontend
</code></pre>
            <h3 id="exercise-5">[[Exercise #5]]</h3>
            <ol>
              <li>
                Nginx Pod 3개로 구성된 Replication Controller를 작성 하세요
              </li>
              <li>Replication Controller 만 삭제 하세요(Pod 는 유지)</li>
              <li>
                남겨진 Nginx Pod를 관리하는 ReplicaSet 을 작성하된 replica 4개로
                구성 하시요
              </li>
              <li>Nginx Pod 를 6개로 Scale Out 하세요</li>
            </ol>
            <h2 id="13deamonset">13.DeamonSet</h2>
            <h3 id="131-데몬셋-생성">13.1 데몬셋 생성</h3>
            <p>goapp-ds.yaml 이라는 이름으로 아래 파일을 작성 합니다.</p>
            <pre><code class="language-{yaml}">piVersion: apps/v1
kind: DaemonSet
metadata:
  name: goapp-on-ssd
spec:
  selector:
    matchLabels:
      app: goapp-pod
  template:
    metadata:
      labels:
        app: goapp-pod
    spec:
      nodeSelector:
        disk: ssd
      containers:
      - name: goapp-container
        image: dangtong/goapp
</code></pre>
            <p>데몬셋을 생성 합니다.</p>
            <pre><code class="language-{bash}">$ kubectl create -f ./goapp-ds.yaml
</code></pre>
            <p>Pod 와 데몬셋을 조회 합니다.</p>
            <pre><code class="language-{bash}">$ kubectl get pod

$ kubectl get ds

NAME           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
goapp-on-ssd   0         0         0       0            0           disk=ssd        &lt;nome&gt;
</code></pre>
            <p>
              조회 하면 Pod 도 존재하지 않고 데몬셋 정보를 조회 해도 모두 0 으로
              나옵닏다. 노드에 disk=ssd 라벨이 없기 때문입니다.
            </p>
            <p>이제 라벨을 추가 합니다.</p>
            <pre><code class="language-{bash}">$ kubectl label node worker01.acorn.com disk=ssd

$ kubectl get pod
NAME                 READY   STATUS    RESTARTS   AGE
goapp-on-ssd-vwvks   1/1     Running   0          7s

$ kubectl label node worker02.acorn.com disk=ssd

$ kubectl get pod
NAME                 READY   STATUS    RESTARTS   AGE
goapp-on-ssd-nbnwz   1/1     Running   0          7s
goapp-on-ssd-vwvks   1/1     Running   0          36s

$ kubectl get ds -o wide
AME           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
goapp-on-ssd   2         2         2       2            2           disk=ssd        10m
</code></pre>
            <h2 id="14deployment">14.Deployment</h2>
            <h3 id="141-deployment-생성">14.1 Deployment 생성</h3>
            <p>
              아래와 같이 nginx 를 서비스 하고 replica 가 3개인 Deployment 를
              작성합니다.(nginx-deploy.yaml)
            </p>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80

</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./nginx-deploy.yaml
</code></pre>
            <h3 id="142-deployment-확인">14.2 Deployment 확인</h3>
            <pre><code class="language-{bash}">kubectl get pod,rs,deploy
NAME                                    READY   STATUS    RESTARTS   AGE
pod/nginx-deployment-54f57cf6bf-dpsn4   1/1     Running   0          30s
pod/nginx-deployment-54f57cf6bf-ghfwm   1/1     Running   0          30s
pod/nginx-deployment-54f57cf6bf-rswwk   1/1     Running   0          30s

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/nginx-deployment-54f57cf6bf   3         3         3       30s

NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx-deployment   3/3     3            3           30s
</code></pre>
            <h3 id="143-이미지-업데이트">14.3 이미지 업데이트</h3>
            <ul>
              <li>기본 방식</li>
            </ul>
            <pre><code class="language-{yaml}">kubectl --record deployment.apps/nginx-deployment set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1
</code></pre>
            <ul>
              <li>단축 방식</li>
            </ul>
            <pre><code class="language-{bash}">kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1 --record
</code></pre>
            <ul>
              <li>
                yaml 파일 수정(.spec.template.spec.containers[0].image 변경)
              </li>
            </ul>
            <pre><code class="language-{bash}">kubectl edit deployment.v1.apps/nginx-deployment
</code></pre>
            <ul>
              <li>롤백</li>
            </ul>
            <div class="language-shell highlighter-rouge notranslate">
              <div class="highlight">
                <pre
                  class="highlight"
                ><code>kubectl <span class="nb">set </span>image deployment.v1.apps/nginx-deployment <span class="nv">nginx</span><span class="o">=</span>nginx:1.7.9 <span class="nt">--record</span><span class="o">=</span><span class="nb">true</span>
</code></pre>
              </div>
            </div>
            <h3 id="144-deployment-scaleout">14.4 Deployment ScaleOut</h3>
            <pre><code class="language-{bash}">kubectl edit deploy goapp-deployment

kubectl scale deploy nginx-deployment
goapp-deployment-5857594fbb-2hhnv   1/1     Running   0          32m
goapp-deployment-5857594fbb-6s9lx   1/1     Running   0          6s
goapp-deployment-5857594fbb-7nqsg   1/1     Running   0          32m
goapp-deployment-5857594fbb-9b28s   1/1     Running   0          32m
</code></pre>
            <h3 id="144-deployment-확인-하기">14.4 deployment 확인 하기</h3>
            <ul>
              <li>롤아웃 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre>
            <ul>
              <li>deployment 상세 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl describe deploy nginx-deployment
</code></pre>
            <h3 id="exercise-6">[[Exercise #6]]</h3>
            <p>1.</p>
            <h2 id="5-서비스-service">5. 서비스 (Service)</h2>
            <h3 id="51-clusterip">5.1 ClusterIP</h3>
            <h4 id="510-nodes-app-생성">5.1.0 nodes app 생성</h4>
            <pre><code class="language-{javascript}">const http = require('http');
const os = require('os');

console.log("Kubia server starting...");

var handler = function(request, response) {
  console.log("Received request from " + request.connection.remoteAddress);
  response.writeHead(200);
  response.end("You've hit " + os.hostname() + "\n");
};

var www = http.createServer(handler);
www.listen(8080);
</code></pre>
            <h4 id="511-pod-생성">5.1.1. pod 생성</h4>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nodeapp-deploy
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nodeapp-pod
  template:
    metadata:
      labels:
        app: nodeapp-pod
    spec:
      containers:
      - name: nodeapp-container
        image: dangtong/nodeapp
        ports:
        - containerPort: 8080
</code></pre>
            <h4 id="512-yaml을-통한-clusterip-생성">
              5.1.2 yaml을 통한 ClusterIP 생성
            </h4>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
  name: nodeapp-service
spec:
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: nodeapp-pod
</code></pre>
            <h4 id="513-서비스-상태-확인">5.1.3 서비스 상태 확인</h4>
            <pre><code class="language-{bash}">kubectl get  po,deploy,svc

NAME                                      READY   STATUS    RESTARTS   AGE
pod/nodeapp-deployment-55688d9d4b-8pzsk   1/1     Running   0          2m45s
pod/nodeapp-deployment-55688d9d4b-pslvb   1/1     Running   0          2m46s
pod/nodeapp-deployment-55688d9d4b-whbk8   1/1     Running   0          2m46s

NAME                                 READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nodeapp-deployment   3/3     3            3           2m46s

NAME                      TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)        AGE
nodeapp-service   ClusterIP      10.101.249.42    &lt;none&gt;           80/TCP         78s
</code></pre>
            <h4 id="514-서비스-확인">5.1.4 서비스 확인</h4>
            <pre><code class="language-{bash}">curl http://10.101.249.42  #여러번 수행 하기

You've hit nodeapp-deployment-55688d9d4b-8pzsk
</code></pre>
            <h4 id="515-원격-pod에서-curl-명령-수행하기">
              5.1.5 원격 Pod에서 curl 명령 수행하기
            </h4>
            <pre><code class="language-{bash}">kubectl exec nodeapp-deployment-55688d9d4b-8pzsk -- curl -s http://10.101.249.42

You've hit nodeapp-deployment-55688d9d4b-whbk8
</code></pre>
            <blockquote>
              <p>.더블 대시는 kubectl 명령의의 종료를 가르킴</p>
            </blockquote>
            <h4 id="516-서비스-삭제">5.1.6 서비스 삭제</h4>
            <pre><code class="language-{bash}">kubectl delete svc nodeapp-service
</code></pre>
            <h3 id="52-nodeport">5.2 NodePort</h3>
            <h4 id="521-yaml-을-이용한-nodeport-생성-gcp-에서-수행-하기">
              5.2.1 yaml 을 이용한 NodePort 생성 (GCP 에서 수행 하기)
            </h4>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
  name: node-nodeport
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30123
  selector:
    app:  node
</code></pre>
            <h4 id="522-nodeport-조회">5.2.2 NodePort 조회</h4>
            <pre><code class="language-{bash}">kubectl get po,rs,svc

NAME                                      READY   STATUS    RESTARTS   AGE
pod/nodeapp-deployment-55688d9d4b-8pzsk   1/1     Running   0          145m
pod/nodeapp-deployment-55688d9d4b-pslvb   1/1     Running   0          145m
pod/nodeapp-deployment-55688d9d4b-whbk8   1/1     Running   0          145m

NAME                                            DESIRED   CURRENT   READY   AGE
replicaset.apps/nodeapp-deployment-55688d9d4b   3         3         3       145m

NAME                       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
service/kubernetes         ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        10d
service/nodeapp-nodeport   NodePort    10.108.30.68   &lt;none&gt;        80:30123/TCP   4m14s
</code></pre>
            <h4 id="523-nodeport-를-통한-서비스-접속-확인여러번-수행">
              5.2.3 NodePort 를 통한 서비스 접속 확인(여러번 수행)
            </h4>
            <pre><code class="language-{bash}">$ curl http://localhost:30123
You've hit nodeapp-deployment-55688d9d4b-pslvb

$ curl http://localhost:30123
You've hit nodeapp-deployment-55688d9d4b-whbk8

$ curl http://localhost:30123
You've hit nodeapp-deployment-55688d9d4b-pslvb

</code></pre>
            <h4 id="524-nodeport-삭제">5.2.4 NodePort 삭제</h4>
            <pre><code class="language-{bash}">kubectl delete svc nodeapp-nodeport
</code></pre>
            <h3 id="53-loadbalancer-gcp-에서-수행">
              5.3 LoadBalancer (GCP 에서 수행)
            </h3>
            <h4 id="531-yaml-파일로-deployment-생성">
              5.3.1 yaml 파일로 deployment 생성
            </h4>
            <pre><code class="language-{bash}">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nodeapp-deployment
  labels:
    app: nodeapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nodeapp-pod
  template:
    metadata:
      labels:
        app: nodeapp-pod
    spec:
      containers:
      - name: nodeapp-container
        image: dangtong/nodeapp
        ports:
        - containerPort: 8080
</code></pre>
            <h4 id="532-서비스-확인">5.3.2 서비스 확인</h4>
            <pre><code class="language-{bash}">$ kubectl get po,rs,deploy

NAME                                      READY   STATUS    RESTARTS   AGE
pod/nodeapp-deployment-7d58f5d487-7hphx   1/1     Running   0          20m
pod/nodeapp-deployment-7d58f5d487-d74rp   1/1     Running   0          20m
pod/nodeapp-deployment-7d58f5d487-r8hq8   1/1     Running   0          20m
NAME                                                  DESIRED   CURRENT   READY   AGE
replicaset.extensions/nodeapp-deployment-7d58f5d487   3         3         3       20m
NAME                                       READY   UP-TO-DATE   AVAILABLE   AGE
deployment.extensions/nodeapp-deployment   3/3     3            3           20m
</code></pre>
            <pre><code class="language-{bash}">kubectl get po -o wide

NAME                                  READY   STATUS    RESTARTS   AGE   IP           NODE                                  NOMINATED NODE   READINESS GATES
nodeapp-deployment-7d58f5d487-7hphx   1/1     Running   0          21m   10.32.2.10   gke-gke1-default-pool-ad44d907-cq8j
nodeapp-deployment-7d58f5d487-d74rp   1/1     Running   0          21m   10.32.2.12   gke-gke1-default-pool-ad44d907-cq8j
nodeapp-deployment-7d58f5d487-r8hq8   1/1     Running   0          21m   10.32.2.11   gke-gke1-default-pool-ad44d907-cq8j
</code></pre>
            <h4 id="532-nodeapp-접속-해보기">5.3.2 nodeapp 접속 해보기</h4>
            <pre><code class="language-{bash}">$ kubectl exec nodeapp-deployment-7d58f5d487-7hphx -- curl -s http://10.32.2.10:8080
또는
$ kubectl exec -it nodeapp-deployment-7d58f5d487-7hphx bash

$ curl http://10.32.2.10:8080
You've hit nodeapp-deployment-7d58f5d487-7hphx
</code></pre>
            <h4 id="533-yaml-파일을-이용해-loadbalancer-생성">
              5.3.3 yaml 파일을 이용해 LoadBalancer 생성
            </h4>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
  name:  nodeapp-lb
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: nodeapp-pod
</code></pre>
            <h4 id="535-loadbalancer-생성-확인">
              5.3.5 LoadBalancer 생성 확인
            </h4>
            <pre><code class="language-{bash}">kubectl get svc

NAME         TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
kubernetes   ClusterIP      10.36.0.1      &lt;none&gt;        443/TCP        7d21h
nodeapp-lb   LoadBalancer   10.36.14.234   &lt;pending&gt;     80:31237/TCP   33s
</code></pre>
            <p>현재 pending 상태임 20초 정도 지나면</p>
            <pre><code class="language-{bash}">kubectl get svc

NAME         TYPE           CLUSTER-IP     EXTERNAL-IP      PORT(S)        AGE
kubernetes   ClusterIP      10.36.0.1      &lt;none&gt;           443/TCP        7d21h
nodeapp-lb   LoadBalancer   10.36.14.234   35.221.179.171   80:31237/TCP   45s
</code></pre>
            <h4 id="536-서비스-확인">5.3.6 서비스 확인</h4>
            <pre><code class="language-{bash}">curl http://35.221.179.171

You've hit nodeapp-deployment-7d58f5d487-r8hq8
</code></pre>
            <h3 id="54-ingress-gcp-에서-수행">5.4 Ingress (GCP 에서 수행)</h3>
            <h4 id="541-deployment-생성">5.4.1 Deployment 생성</h4>
            <ul>
              <li>nginx / goapp deployment 생성</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx-container
        image: nginx:1.7.9
        ports:
        - containerPort: 80
---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: goapp-deployment
  labels:
    app: goapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: goapp
  template:
    metadata:
      labels:
        app: goapp
    spec:
      containers:
      - name: goapp-container
        image: dangtong/goapp
        ports:
        - containerPort: 8080
</code></pre>
            <h4 id="542-service-생성">5.4.2 Service 생성</h4>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
  name:  nginx-lb
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: nginx

---
apiVersion: v1
kind: Service
metadata:
  name:  goapp-lb
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: goapp
</code></pre>
            <h4 id="543-ingress-생성">5.4.3 Ingress 생성</h4>
            <pre><code class="language-{yaml}">apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: nginx-goapp-ingress
spec:
  tls:
  - hosts:
    - nginx.acorn.com
    - goapp.acorn.com
    secretName: acorn-secret
  rules:
  - host: nginx.acorn.com
    http:
      paths:
      - path: /
        backend:
          serviceName: nginx-lb
          servicePort: 80
  - host: goapp.acorn.com
    http:
      paths:
      - path: /
        backend:
          serviceName: goapp-lb
          servicePort: 80
</code></pre>
            <h4 id="544-ingress-조회">5.4.4 Ingress 조회</h4>
            <pre><code class="language-{bash}">kubectl get ingress

NAME                  HOSTS                             ADDRESS   PORTS     AGE
nginx-goapp-ingress   nginx.acorn.com,goapp.acorn.com             80, 443   15s
</code></pre>
            <blockquote>
              <p>Ingress 가 완전히 생성되기 까지 시간이 걸립니다. 2~5분 소요</p>
            </blockquote>
            <p>다시 조회 합니다</p>
            <pre><code class="language-{bash}">kubectl get ingress

NAME                  HOSTS                             ADDRESS          PORTS     AGE
nginx-goapp-ingress   nginx.acorn.com,goapp.acorn.com   35.227.227.127   80, 443   13m
</code></pre>
            <h4 id="545-etchosts-파일-수정">5.4.5 /etc/hosts 파일 수정</h4>
            <pre><code class="language-{bash}">sudo vi /etc/hosts

35.227.227.127 nginx.acorn.com goapp.acorn.com
</code></pre>
            <h4 id="546-서비스-확인">5.4.6 서비스 확인</h4>
            <pre><code class="language-{bash}">$ curl http://goapp.acorn.com
hostname: goapp-deployment-d7564689f-6rrzw

$ curl http://nginx.acorn.com
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

</code></pre>
            <h4 id="547-https-서비스-tls-offload">
              5.4.7 HTTPS 서비스 (TLS OffLoad)
            </h4>
            <ul>
              <li>인증서 생성 및 인증서 secret 등록</li>
            </ul>
            <pre><code class="language-{bash}">openssl genrsa -out server.key 2048

openssl req -new -x509 -key server.key -out server.cert -days 360 -subj /CN=nginx.acorn.com

kubectl create  secret tls acorn-secret --cert=server.cert --key=server.key
</code></pre>
            <ul>
              <li>테스트</li>
            </ul>
            <pre><code class="language-{bash}">$ curl -k https://nginx.acorn.com

$ curl -k https://goapp.acorn.com
</code></pre>
            <h2 id="7volums">7.Volums</h2>
            <h3 id="71-emptydir-gcp-에서-수행">7.1 EmptyDir (GCP 에서 수행)</h3>
            <h4 id="711-docker-이미지-만들기">7.1.1 Docker 이미지 만들기</h4>
            <p>아래와 같이 폴더를 만들고 ./fortune/docimg 폴더로 이동합니다.</p>
            <pre><code class="language-{bash}">$ mkdir -p ./fortune/docimg
$ mkdir -p ./fortune/kubetmp

</code></pre>
            <p>
              아래와 같이 docker 이미지를 작성하기 위해 bash 로 Application을
              작성 합니다.
            </p>
            <p>파일명 : fortuneloop.sh</p>
            <pre><code class="language-{bash}">#!/bin/bash
trap "exit" SIGINT
mkdir /var/htdocs
while :
do
    echo $(date) Writing fortune to /var/htdocs/index.html
    /usr/games/fortune  &gt; /var/htdocs/index.html
    sleep 10
done
</code></pre>
            <p>Dockerfile 을 작성 합니다.</p>
            <pre><code class="language-{dockerfile}">FROM ubuntu:latest
RUN apt-get update; apt-get -y install fortune
ADD fortuneloop.sh /bin/fortuneloop.sh
ENTRYPOINT /bin/fortuneloop.sh
</code></pre>
            <p>Dcoker 이미지를 만듭니다.</p>
            <pre><code class="language-{bash}">$ docker build -t dangtong/fortune .
</code></pre>
            <p>Docker 이미지를 Docker Hub 에 push 합니다.</p>
            <pre><code class="language-{bash}">$ docker login
$ docker push dangtong/fortune
</code></pre>
            <h4 id="712-deployment-작성">7.1.2 Deployment 작성</h4>
            <p>fortune APP을 적용하기 위해 Deployment 를 작성 합니다.</p>
            <pre><code class="language-{bash}">cd ../ktmp/
vi fortune-deploy.yaml
</code></pre>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: Deployment
metadata:
  name: fortune-deployment
  labels:
    app: fortune
spec:
  replicas: 3
  selector:
    matchLabels:
      app: fortune
  template:
    metadata:
      labels:
        app: fortune
    spec:
      containers:
      - image: dangtong/fortune
        name: html-generator
        volumeMounts:
        - name: html
          mountPath: /var/htdocs
      - image: nginx:alpine
        name: web-server
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
          readOnly: true
        ports:
          - containerPort: 80
            protocol: TCP
      volumes:
      - name: html
        emptyDir: {}
</code></pre>
            <blockquote>
              <p>
                html 볼륨을 html-generator 및 web-seerver 컨테이너에 모두 마운트
                하였습니다.
              </p>
              <p>
                html 볼륨에는 /var/htdocs 및 /usr/share/nginx/html 이름 으로
                서로 따른 컨테이너에서 바라 보게 됩니다.
              </p>
              <p>
                다만, web-server 컨테이너는 읽기 전용(reeadOnly) 으로만 접근
                하도록 설정 하였습니다.
              </p>
            </blockquote>
            <blockquote>
              <p>
                emptDir 을 디스크가 아닌 메모리에 생성 할 수도 있으며, 이를
                위해서는 아래와 같이 설정을 바꾸어 주면 됩니다.
              </p>
              <p>emptyDir:</p>
              <p>​ medium: Memory</p>
            </blockquote>
            <h4 id="713-loadbalancer-작성">7.1.3 LoadBalancer 작성</h4>
            <pre><code class="language-{bash}">vi fortune-lb.yaml
</code></pre>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
  name: fortune-lb
spec:
  selector:
    app: fortune
  ports:
    - port: 80
      targetPort: 80
  type: LoadBalancer
  externalIPs:
  - 192.168.56.108
</code></pre>
            <h4 id="714-deployment-및-loadbalancer-생성">
              7.1.4 Deployment 및 Loadbalancer 생성
            </h4>
            <pre><code class="language-{bash}">$ kubectl apply -f ./fortune-deploy.yaml
$ kubectl apply -f ./fortune-lb.yaml
</code></pre>
            <h4 id="715-서비스-확인">7.1.5. 서비스 확인</h4>
            <pre><code class="language-{bash}">curl http://192.168.56.108
</code></pre>
            <h3 id="72-git-emptydir">7.2 Git EmptyDir</h3>
            <h4 id="721-웹서비스용-git-리포지토리-생성">
              7.2.1 웹서비스용 Git 리포지토리 생성
            </h4>
            <p>Appendix3 . Git 계정 생성 및 Sync 참조</p>
            <h4 id="722-deployment-용-yaml-파일-작성">
              7.2.2 Deployment 용 yaml 파일 작성
            </h4>
            <pre><code class="language-{bash}">$ cd ./gitvolume/kubetmp
$ vi gitvolume-deploy.yaml
</code></pre>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: Deployment
metadata:
  name: gitvolume-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - image: nginx:alpine
        name: web-server
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
          readOnly: true
        ports:
          - containerPort: 80
            protocol: TCP
      volumes:
      - name: html
        gitRepo:
          repository: https://github.com/dangtong76/k8s-web.git
          revision: master
          directory: .

</code></pre>
            <h4 id="723-deployment-생성">7.2.3 Deployment 생성</h4>
            <pre><code class="language-{bash}">$ kubectl apply -f ./gitvolume-deploy.yaml
</code></pre>
            <h3 id="73-gce-persisteent-disk-사용하기">
              7.3 GCE Persisteent DISK 사용하기
            </h3>
            <h4 id="731-persistent-disk-생성">7.3.1. Persistent DISK 생성</h4>
            <ul>
              <li>리전/존 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ gcloud container clusters list
</code></pre>
            <ul>
              <li>Disk 생성</li>
            </ul>
            <pre><code class="language-{bash}">$ gcloud compute disks create --size=16GiB --zone asia-northeast1-b  mongodb
# 삭제
# gcloud compute disks delete mongodb --zone asia-northeast1-b
</code></pre>
            <h4 id="732-pod-생성을-위한-yaml-파일-작성">
              7.3.2 Pod 생성을 위한 yaml 파일 작성
            </h4>
            <ul>
              <li>파일명 : gce-pv.yaml</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: mongodb
spec:
  volumes:
  - name: mongodb-data
    gcePersistentDisk:
      pdName: mongodb
      fsType: ext4
  containers:
  - image: mongo
    name:  mongodb
    volumeMounts:
    -  name: mongodb-data
       mountPath: /data/db
    ports:
    - containerPort: 27017
      protocol: TCP
</code></pre>
            <ul>
              <li>Pod 생성</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl apply -f ./gce-pv.yaml

$ kubectl get po

NAME      READY   STATUS    RESTARTS   AGE
mongodb   1/1     Running   0          8m42s
</code></pre>
            <ul>
              <li>Disk 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl describe pod mongodb

...(중략)

Volumes:
  mongodb-data:
    Type:       GCEPersistentDisk (a Persistent Disk resource in Google Compute Engine)
    PDName:     mongodb  # 디스크이름
    FSType:     ext4
    Partition:  0
    ReadOnly:   false
  default-token-dgkd5:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-dgkd5
    Optional:    false

...(중략)

</code></pre>
            <h4 id="733-mongodb-접속-및-데이터-insert">
              7.3.3 Mongodb 접속 및 데이터 Insert
            </h4>
            <ul>
              <li>접속</li>
            </ul>
            <pre><code class="language-{bash}">kubectl exec -it mongodb mongo
</code></pre>
            <ul>
              <li>데이터 Insert</li>
            </ul>
            <pre><code class="language-{bash}">&gt; use mystore
&gt; db.foo.insert({"first-name" : "dangtong"})

&gt; db.foo.find()
{ "_id" : ObjectId("5f9c4127caf2e6464e18331c"), "first-name" : "dangtong" }

&gt; exit
</code></pre>
            <h4 id="734-mongodb-pod-재시작">7.3.4 MongoDB Pod 재시작</h4>
            <ul>
              <li>MongoDB 중단</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl delete pod mongodb
</code></pre>
            <ul>
              <li>MongoDB Pod 재생성</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl apply -f ./gce-pv.yaml
</code></pre>
            <ul>
              <li>기존에 Insert 한 데이터 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl exec -it mongodb mongo

&gt; use mystore

&gt; db.foo.find()
{ "_id" : ObjectId("5e9684134384860bc207b1f9"), "first-name" : "dangtong" }
</code></pre>
            <h4 id="735-pod-삭제">7.3.5 Pod 삭제</h4>
            <pre><code class="language-{bash}">$ kubectl delete po mongodb
</code></pre>
            <h3 id="74-persistentvolume-및-persistentvolumeclaim">
              7.4 PersistentVolume 및 PersistentVolumeClaim
            </h3>
            <h4 id="741-persistentvolume-생성">7.4.1 PersistentVolume 생성</h4>
            <p>gce-pv2.yaml 로 작성</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: PersistentVolume
metadata:
   name: mongodb-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
  - ReadWriteOnce
  - ReadOnlyMany
  persistentVolumeReclaimPolicy: Retain
  gcePersistentDisk:
   pdName: mongodb
   fsType: ext4
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./gce-pv2.yaml
</code></pre>
            <pre><code class="language-{bash}">kubectl get pv
</code></pre>
            <h4 id="742-persistentvolumeclaim-생성">
              7.4.2 PersistentVolumeClaim 생성
            </h4>
            <p>gce-pvc.yaml 로 작성</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pvc
spec:
  resources:
    request:
      storage: 1Gi
  accessModes:
  - ReadWriteOnce
  storageClassName: ""
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./gce-pvc.yaml
</code></pre>
            <pre><code class="language-{bash}">kubectl get pvc
</code></pre>
            <h4 id="743-pv-pvc-를-이용한-pod-생성">
              7.4.3 PV, PVC 를 이용한 Pod 생성
            </h4>
            <p>gce-pod.yaml 파일 생성</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: mongodb
spec:
  containers:
  - image: mongo
    name: mongodb
    volumeMounts:
    - name: mongodb-data
      mountPath: /data/db
  - Ports:
  - containerPort: 27017
    protocol: TCP
  volumes:
  - name: mongodb-data
    persistentVolumeClaim:
      claimName: mongdodb-pvc
</code></pre>
            <div class="language-bash highlighter-rouge notranslate">
              <div class="highlight">
                <pre
                  class="highlight"
                ><code><span class="nv">$ </span>kubectl apply <span class="nt">-f</span> ./gce-pod.yaml
</code></pre>
              </div>
            </div>
            <pre><code class="language-{bash}">$ kubectl get po,pv,pvc
</code></pre>
            <h4 id="744-mongodb-접속-및-데이터-확인">
              7.4.4 Mongodb 접속 및 데이터 확인
            </h4>
            <pre><code class="language-{bash}">$ kubectl exec -it mongodb mongo

&gt; use mystore

&gt; db.foo.find()

</code></pre>
            <h3 id="75-persistent-volume-의-동적-할당">
              7.5 Persistent Volume 의 동적 할당
            </h3>
            <h4 id="751-storageclass-를-이용해-스토리지-유형-정의">
              7.5.1 StorageClass 를 이용해 스토리지 유형 정의
            </h4>
            <ul>
              <li>gce-sclass.yaml</li>
              <li>존환인 : <strong>gcloud</strong> container clusters list</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-ssd
  zone: asia-northeast1-b  #클러스터를 만든 지역으로 설정 해야함
</code></pre>
            <pre><code class="language-{bash}">$ kubectl apply -f ./gce-sclass.yaml
</code></pre>
            <h4 id="752-pvc-생성">7.5.2 PVC 생성</h4>
            <ul>
              <li>gce-pvc-sclass.yaml</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
   name: mongodb-pvc
spec:
  storageClassName: fast
  resources:
    requests:
      storage: 100Mi
  accessModes:
    - ReadWriteOnce
</code></pre>
            <pre><code class="language-{bash}">$ kubectl apply -f ./gce-pvc-sclass.yaml
</code></pre>
            <h4 id="753-pv-및-pvc-확인">7.5.3 PV 및 PVC 확인</h4>
            <ul>
              <li>pvc 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl get pvc mongdb-pvc

</code></pre>
            <ul>
              <li>pv 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl get pv
</code></pre>
            <h4 id="754-pvc-를-이용한-pod-생성">
              7.5.4 PVC 를 이용한 POD 생성
            </h4>
            <p>파일명 : gce-pod.yaml 파일 생성</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: mongodb
spec:
  containers:
  - image: mongo
    name: mongodb
    volumeMounts:
    - name: mongodb-data
      mountPath: /data/db
  - Ports:
  - containerPort: 27017
    protocol: TCP
  volumes:
  - name: mongodb-data
    persistentVolumeClaim:
      claimName: mongdodb-pvc
</code></pre>
            <h2 id="8-configmap">8. ConfigMap</h2>
            <h4 id="81-도커에서-매개변수-전달">8.1 도커에서 매개변수 전달</h4>
            <h5 id="811-디렉토리-생성-및-소스-코드-작성">
              8.1.1 디렉토리 생성 및 소스 코드 작성
            </h5>
            <pre><code class="language-{bash}">mkdir -p ./configmap/docimg/indocker
mkdir -p ./configmap/kubetmp

cd ./configmap/docimg/indocker
vi fortuneloop.sh
</code></pre>
            <pre><code class="language-{bash}">#!/bin/bash
trap "exit" SIGINT
INTERVAL=$1
echo "Configured to generate neew fortune every " $INTERVAL " seconds"
mkdir /var/htdocs
while :
do
    echo $(date) Writing fortune to /var/htdocs/index.html
    /usr/games/fortune  &gt; /var/htdocs/index.html
    sleep $INTERVAL
done
</code></pre>
            <pre><code class="language-{bash}">chmod 755 fortuneloop.sh
</code></pre>
            <h5 id="812-docker-이미지-생성">8.1.2 Docker 이미지 생성</h5>
            <pre><code class="language-{bash}">$ vi dockerfile
</code></pre>
            <pre><code class="language-{dockerfile}">FROM ubuntu:latest
RUN apt-get update;  apt-get -y install fortune
ADD fortuneloop.sh /bin/fortuneloop.sh
ENTRYPOINT ["/bin/fortuneloop.sh"]
CMD ["10"]  # args가 없으면 10초
</code></pre>
            <pre><code class="language-{bash}">$ docker build -t dangtong/fortune:args .
$ docker push dangtong/fortune:args
</code></pre>
            <blockquote>
              <p>테스트를 위해 다음과 같이 수행 가능</p>
              <p>$ docker run -it dangtong/fortune:args # 기본 10초 수행</p>
              <p>
                $ docker run -it dangtong/fortune:args 15 # 15초로 매개변수 전달
              </p>
            </blockquote>
            <h5 id="813-pod생성">8.1.3 Pod생성</h5>
            <p>파일명 : config-fortune-pod.yaml</p>
            <pre><code class="language-{bash}">cd ../../kubetmp
vi config-fortune-indocker-pod.yaml
</code></pre>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: fortune5s
spec:
  containers:
  - image: dangtong/fortune:args
    args: ["5"]
    name: html-generator
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
     ports:
     - containerPort: 80
       protocol: TCP
  volumes:
  - name: html
    emptyDir: {}
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./config-fortune-indockeer-pod.yaml
</code></pre>
            <h4 id="82-yaml-파일을-통한-매개변수-전달">
              8.2 Yaml 파일을 통한 매개변수 전달
            </h4>
            <h5 id="821-fortuneloopsh-작성">8.2.1 fortuneloop.sh 작성</h5>
            <pre><code class="language-{bash}">cd ../
mkdir -p ./docimg/inyaml
cd ./docimg/inyaml
vi fortuneloop.sh
</code></pre>
            <pre><code class="language-{bash}">#!/bin/bash
trap "exit" SIGINT
echo "Configured to generate neew fortune every " $INTERVAL " seconds"
mkdir /var/htdocs
while :
do
    echo $(date) Writing fortune to /var/htdocs/index.html
    /usr/games/fortune  &gt; /var/htdocs/index.html
    sleep $INTERVAL
done
</code></pre>
            <h5 id="822-dockerfile-작성-및-build">
              8.2.2 Dockerfile 작성 및 build
            </h5>
            <pre><code class="language-{bash}">$ vi dockerfile
</code></pre>
            <pre><code class="language-{dockerfile}">FROM ubuntu:latest
RUN apt-get update;  apt-get -y install fortune
ADD fortuneloop.sh /bin/fortuneloop.sh
ENTRYPOINT ["/bin/fortuneloop.sh"]
CMD ["10"]  # args가 없으면 10초
</code></pre>
            <pre><code class="language-{bash}">$ docker build -t dangtong/fortune:env .
$ docker push dangtong/fortune:env
</code></pre>
            <h5 id="822-pod-생성및-매개변수-전달을-위한-yaml-파일-작성">
              8.2.2 Pod 생성및 매개변수 전달을 위한 yaml 파일 작성
            </h5>
            <pre><code class="language-{bash}">cd ../../kubetmp
vi config-fortune-inyaml-pod.yaml
</code></pre>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: fortune30s
spec:
  containers:
  - image: dangtong/fortune:env
    env:
    - name: INTERVAL
      value: "30"
    name: html-generator
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    emptyDir: {}
</code></pre>
            <h4 id="83-configmap-을-통한-설정">8.3 ConfigMap 을 통한 설정</h4>
            <h5 id="831-configmap-생성-및-확인">
              8.3.1 ConfigMap 생성 및 확인
            </h5>
            <ul>
              <li>configMap 생성</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl create configmap fortune-config --from-literal=sleep-interval=7
</code></pre>
            <blockquote>
              <p>
                ConfigMap 생성시 이름은 영문자,숫자, 대시, 밑줄, 점 만 포함 할
                수 있습니다.
              </p>
              <p>
                만약 여러개의 매개변수를 저장 할려면
                –from-literal=sleep-interval=5 –from-literal=sleep-count=10 와
                같이 from-literal 부분을 여러번 반복해서 입력 하면 됩니다.
              </p>
            </blockquote>
            <ul>
              <li>configMap 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl get cm fortune-config

NAME             DATA   AGE
fortune-config   1      15s

$ kubectl get configmap fortune-config. -o yaml

apiVersion: v1
data:
  sleep-interval: "7"
kind: ConfigMap
metadata:
  creationTimestamp: "2020-04-16T09:09:33Z"
  name: fortune-config
  namespace: default
  resourceVersion: "1044269"
  selfLink: /api/v1/namespaces/default/configmaps/fortune-config
  uid: 85723e0a-1959-4ace-9365-47c101ebef82
</code></pre>
            <h5 id="832-configmap을-환경변수로-전달한는-yaml-파일-작성">
              8.3.2 ConfigMap을 환경변수로 전달한는 yaml 파일 작성
            </h5>
            <ul>
              <li>Yaml 파일 생성</li>
            </ul>
            <pre><code class="language-{bash}">vi config-fortune-mapenv-pod.yaml
</code></pre>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: fortune7s
spec:
  containers:
  - image: dangtong/fortune:env
    env:
    - name: INTERVAL
      valueFrom:
        configMapKeyRef:
          name: fortune-config
          key: sleep-interval
    name: html-generator
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    emptyDir: {}
</code></pre>
            <h5 id="833-pod-생성-및-확인">8.3.3 Pod 생성 및 확인</h5>
            <ul>
              <li>Pod 생성</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl create -f ./config-fortune-mapenv-pod.yaml
</code></pre>
            <ul>
              <li>Pod 생성 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl get po, cm

$ kubectl describe cm

Name:         fortune-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
sleep-interval:
----
7
Events:  &lt;none&gt;
</code></pre>
            <ul>
              <li>configMap 삭제</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl delete configmap fortune-config
</code></pre>
            <h4 id="84-configmap-volume-사용-파일숨김-vm에서-수행">
              8.4 ConfigMap Volume 사용 (파일숨김-vm에서 수행)
            </h4>
            <h5 id="841-configmap-생성">8.4.1 ConfigMap 생성</h5>
            <pre><code class="language-{bash}">mkdir config-dir
cd config-dir
vi custom-nginx-config.conf
</code></pre>
            <p>파일명 : custom-nginx-config.conf</p>
            <pre><code class="language-{conf}">server {
	listen				8080;
	server_name		www.acron.com;

	gzip on;
	gzip_types text/plain application/xml;
	location / {
		root	/usr/share/nginx/html;
		index	index.html index.htm;
	}
}
</code></pre>
            <pre><code class="language-{bash}">$ kubectl create configmap fortune-config --from-file=config-dir
</code></pre>
            <h5 id="842-configmap-volume-이용-pod-생성">
              8.4.2 configMap volume 이용 Pod 생성
            </h5>
            <ul>
              <li>Yaml 파일 작성 : config-fortune-mapvol-pod.yaml</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: nginx-configvol
spec:
  containers:
  - image: nginx:1.7.9
    name: web-server
    volumeMounts:
    - name: ls
      mountPath: /etc/nginx/conf.d
      readOnly: true
    ports:
    - containerPort: 8080
      protocol: TCP
  volumes:
  - name: config
    configMap:
      name: fortune-config
</code></pre>
            <blockquote>
              <p>서버에 접속해서 디렉토리 구조를 한번 보는것이 좋습니다.</p>
              <p>kubectl exec -it nginx-pod bash</p>
            </blockquote>
            <pre><code class="language-{bash}">$ kubectl apply -f ./config-fortune-mapvol-pod.yaml
</code></pre>
            <h5 id="843-configmap-volume-참조-확인">
              8.4.3 ConfigMap Volume 참조 확인
            </h5>
            <pre><code class="language-{bash}">$ kubectl get pod -o wide

AME              READY   STATUS    RESTARTS   AGE     IP          NODE
nginx-configvol   1/1     Running   0          9m25s   10.32.0.2   worker01.acorn.com
</code></pre>
            <ul>
              <li>Response 에 압축(gzip)을 사용 하는지 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ curl -H "Accept-Encoding: gzip" -I 10.32.0.2:8080
</code></pre>
            <ul>
              <li>마운트된 configMap 볼륨 내용확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl exec nginx-configvol -c web-server ls /etc/nginx/conf.d

nginx-config.conf
sleep-interval

$ kubectl exec -it nginx-configvol sh
</code></pre>
            <h5 id="844-configmap-동적-변경">8.4.4 ConfigMap 동적 변경</h5>
            <ul>
              <li>사전 테스트</li>
            </ul>
            <pre><code class="language-{bash}">$ curl -H "Accept-Encoding: gzip" -I 10.32.0.2:8080

HTTP/1.1 200 OK
Server: nginx/1.17.9
Date: Fri, 17 Apr 2020 06:10:32 GMT
Content-Type: text/html
Last-Modified: Tue, 03 Mar 2020 14:32:47 GMT
Connection: keep-alive
ETag: W/"5e5e6a8f-264"
Content-Encoding: gzip
</code></pre>
            <ul>
              <li>configMap 변경</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl edit cm fortune-config


</code></pre>
            <p><strong>gzip on</strong> 부분을 **gzip off ** 로 변경 합니다.</p>
            <pre><code class="language-{bash}">apiVersion: v1
data:
  nginx-config.conf: "server {\n  listen\t80;\n  server_name\tnginx.acorn.com;\n\n
    \ gzip off;\n  gzip_types text/plain application/xml;\n  location / {\n    root\t/usr/share/nginx/html;\n
    \   index\tindex.html index.htm;\n  }  \n}\n\n\n"
  nginx-ssl-config.conf: '##Nginx SSL Config'
  sleep-interval: |
    25
kind: ConfigMap
metadata:
  creationTimestamp: "2020-04-16T15:58:42Z"
  name: fortune-config
  namespace: default
  resourceVersion: "1115758"
  selfLink: /api/v1/namespaces/default/configmaps/fortune-config
  uid: 182302d8-f30f-4045-9615-36e24b185ecb
</code></pre>
            <ul>
              <li>변경후 테스트</li>
            </ul>
            <pre><code class="language-{bash}">$ curl -H "Accept-Encoding: gzip" -I 10.32.0.2:8080

HTTP/1.1 200 OK
Server: nginx/1.17.9
Date: Fri, 17 Apr 2020 06:10:32 GMT
Content-Type: text/html
Last-Modified: Tue, 03 Mar 2020 14:32:47 GMT
Connection: keep-alive
ETag: W/"5e5e6a8f-264"
Content-Encoding: gzip
</code></pre>
            <ul>
              <li>reload 로 변경 사항 컨테이너에 알리기</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl  exec nginx-configvol -c web-server -- nginx -s reload
</code></pre>
            <ul>
              <li>최종 테스트</li>
            </ul>
            <pre><code class="language-{bash}">$ curl -H "Accept-Encoding: gzip" -I 10.32.0.2:8080

HTTP/1.1 200 OK
Server: nginx/1.17.9
Date: Fri, 17 Apr 2020 06:10:32 GMT
Content-Type: text/html
Last-Modified: Tue, 03 Mar 2020 14:32:47 GMT
Connection: keep-alive
ETag: W/"5e5e6a8f-264"
</code></pre>
            <h4 id="85-configmap-volume파일-추가">
              8.5 ConfigMap Volume(파일 추가)
            </h4>
            <h5 id="851-configmap-volume-이용-pod-생성">
              8.5.1 configMap volume 이용 Pod 생성
            </h5>
            <ul>
              <li>Yaml 파일 작성 : config-fortune-mapvol-pod2.yaml</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: nginx-configvol
spec:
  containers:
  - image: nginx:1.7.9
    name: web-server
    volumeMounts:
    - name: config
      mountPath: /etc/nginx/conf.d/default.conf
      subPath: nginx-config.conf # 주의 : configmap 의 key 와 파일명이 일치 해야합니다.
      readOnly: true
    ports:
    - containerPort: 8080
      protocol: TCP
  volumes:
  - name: config
    configMap:
      name: fortune-config
      defaultMode: 0660
</code></pre>
            <blockquote>
              <p>
                nginx 1.7.9 이상 버전, 예를 들면 nginx:latest 로 하면
                /etc/nginx/conf.d 폴더내에 default.conf 파일만 존재 합니다.
                Example_cat tssl.conf 파일은 없습니다. 테스트를 위해서
                nginx:1.7.9 버전으로 설정 한것입니다.
              </p>
            </blockquote>
            <pre><code class="language-{bash}">$ kubectl apply -f ./config-fortune-mapvol-pod.yaml
</code></pre>
            <h5 id="852-서비스-및-confimap-확인">
              8.5.2 서비스 및 ConfiMap 확인
            </h5>
            <ul>
              <li>서비스 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ curl -H "Accept-Encoding: gzip" -I 10.32.0.2:8080
</code></pre>
            <ul>
              <li>configMap 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl exec nginx-configvol -c web-server ls /etc/nginx/conf.d
</code></pre>
            <h5 id="853-configmap-추가">8.5.3 ConfigMap 추가</h5>
            <ul>
              <li>configMap 추가</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl edit cm fortune-config
</code></pre>
            <p>아래와 같이 nginx-ssl-config.conf 키값을 추가합니다.</p>
            <pre><code class="language-{bash}">apiVersion: v1
data:
  nginx-config.conf: "server {\n  listen\t80;\n  server_name\tnginx.acorn.com;\n\n
    \ gzip on;\n  gzip_types text/plain application/xml;\n  location / {\n    root\t/usr/share/nginx/html;\n
    \   index\tindex.html index.htm;\n  }  \n}\n\n\n"
  nginx-ssl-config.conf: ""##Nginx SSL Config" # 이부분이 추가됨
  sleep-interval: |
    25
kind: ConfigMap
metadata:
  creationTimestamp: "2020-04-16T15:58:42Z"
  name: fortune-config
  namespace: default
  resourceVersion: "1098337"
  selfLink: /api/v1/namespaces/default/configmaps/fortune-config
  uid: 182302d8-f30f-4045-9615-36e24b185ecb
</code></pre>
            <h5 id="854-configmap-추가된-pod-생성">
              8.5.4 ConfigMap 추가된 Pod 생성
            </h5>
            <ul>
              <li>설정 파일 추가 하기위해 yaml 파일 수정</li>
            </ul>
            <p>파일명 : config-fortune-mapvol-pod3.yaml</p>
            <pre><code class="language-{yaml}">kind: Pod
metadata:
  name: nginx-configvol
spec:
  containers:
  - image: nginx:1.7.9
    name: web-server
    volumeMounts:
    - name: config #default.conf 파일 교체
      mountPath: /etc/nginx/conf.d/default.conf
      subPath: nginx-config.conf
      readOnly: true
    - name: config #example_ssl.conf 파일 교체
      mountPath: /etc/nginx/conf.d/example_ssl.conf
      subPath: nginx-ssl-config.conf
      readOnly: true
    ports:
    - containerPort: 8080
      protocol: TCP
  volumes:
  - name: config
    configMap:
      name: fortune-config
      defaultMode: 0660
</code></pre>
            <pre><code class="language-{bash}">$ kubectl apply -f ./ config-fortune-mapvol-pod3.yaml
</code></pre>
            <h5 id="856-추가된-configmap-확인">8.5.6 추가된 ConfigMap 확인</h5>
            <ul>
              <li>서비스 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ curl http://10.32.0.4
</code></pre>
            <ul>
              <li>configMap 확인</li>
            </ul>
            <pre><code class="language-{bash}">$ kubectl exec -it nginx-configvol bash

$ cd /etc/nginx/conf.d
$ ls -al

</code></pre>
            <h2 id="9-secret">9. Secret</h2>
            <pre><code class="language-{bash}">mkdir -p ./secret/cert
mkdir -p ./secret/config
mkdir -p ./secret/kubetmp
</code></pre>
            <h3 id="91-secret-생성-fortune-https">
              9.1 Secret 생성 (fortune-https)
            </h3>
            <pre><code class="language-{bash}">cd ./secret/cert
</code></pre>
            <pre><code class="language-{bash}">openssl genrsa -out https.key 2048
openssl req -new -x509 -key https.key -out https.cert -days 360 -subj /CN=*.acron.com
</code></pre>
            <pre><code class="language-{bash}">kubectl create secret generic fortune-https --from-file=https.key --from-file=https.cert
</code></pre>
            <h3 id="92-ssl-용-niginx-설정-생성fortune-config">
              9.2 SSL 용 niginx 설정 생성(fortune-config)
            </h3>
            <pre><code class="language-{bash}">cd ./secret/config
vi custom-nginx-config.conf
</code></pre>
            <pre><code class="language-{bash}">server {
	listen				8080;
  listen				443 ssl;
	server_name		www.acron.com;
	ssl_certificate		certs/https.cert;
	ssl_certificate_key	certs/https.key;
	ssl_protocols		TLSv1 TLSv1.1 TLSv1.2;
	ssl_ciphers		HIGH:!aNULL:!MD5;
	gzip on;
	gzip_types text/plain application/xml;
	location / {
		root	/usr/share/nginx/html;
		index	index.html index.htm;
	}
}
</code></pre>
            <pre><code class="language-{bash}">vi sleep-interval
7
</code></pre>
            <pre><code class="language-{bash}">kubectl create cm fortune-config --from-file=./config
</code></pre>
            <h3 id="93-pod-생성">9.3 POD 생성</h3>
            <ul>
              <li>Pod 생성 : 8.3.2 의 yaml 파일 참조</li>
              <li>파일명 : secret-pod.yaml</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Pod
metadata:
  name: fortune-https
spec:
  containers:
  - image: dangtong/fortune:env
    env:
    - name: INTERVAL
      valueFrom:
        configMapKeyRef:
          name: fortune-config
          key: sleep-interval
    name: html-generator
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    - name: config # 추가
      mountPath: /etc/nginx/conf.d
      readOnly: true
    - name: certs # 추가
      mountPath: /etc/nginx/certs/
      readOnly: true
    ports:
    - containerPort: 80
    - containerPort: 443 # 추가
  volumes:
  - name: html
    emptyDir: {}
  - name: config # 추가
    configMap:
      name: fortune-config
      items:
      - key: custom-nginx-config.conf
        path: https.conf
  - name: certs  #추가
    secret:
      secretName: fortune-https
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./secret-pod.yaml
</code></pre>
            <h3 id="94-서비스-확인">9.4 서비스 확인</h3>
            <pre><code class="language-{bash}">kubectl port-forward fortune-https 8443:443 &amp;
</code></pre>
            <pre><code class="language-{bash}">curl https://localhsot:8443 -k
curl https://localhost:8443 -k -v
</code></pre>
            <h3 id="exercise-7">[[Exercise #7]]</h3>
            <h4 id="1-mysql-구성하기">1. Mysql 구성하기</h4>
            <h5 id="11-서비스-구성">1.1 서비스 구성</h5>
            <p>파일명 : mysql-svc.yaml</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  ports:
    - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None
</code></pre>
            <h5 id="12-볼륨-구성">1.2 볼륨 구성</h5>
            <p>파일명 : mysql-pvc.yaml</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  labels:
    app: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
</code></pre>
            <h5 id="13-pod-구성">1.3 Pod 구성</h5>
            <p>파일명 : mysql-deploy.yaml</p>
            <pre><code class="language-{yaml}">apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
      - image: mysql:5.6
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f
</code></pre>
            <h4 id="2-wordpress-서비스-구성">2. WordPress 서비스 구성</h4>
            <h5 id="21-loadbalancer-구성">2.1 LoadBalancer 구성</h5>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
    tier: frontend
  type: LoadBalancer
</code></pre>
            <h5 id="22-pvc-구성">2.2 PVC 구성</h5>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wp-pv-claim
  labels:
    app: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
</code></pre>
            <h5 id="23-wordpress-구성">2.3 WordPress 구성</h5>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
      - image: wordpress:4.8-apache
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: wordpress-mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wp-pv-claim
</code></pre>
            <h2 id="10-statefullset-gcp-수행">10. StatefullSet (GCP 수행)</h2>
            <h3 id="101-애플리케이션-이미지-작성">
              10.1 애플리케이션 이미지 작성
            </h3>
            <h4 id="1011-appjs-작성">10.1.1 app.js 작성</h4>
            <pre><code class="language-{javascript}">const http = require('http');
const os = require('os');
const fs = require('fs');

const dataFile = "/var/data/kubia.txt";
const port  = 8080;

// 파일 존재  유/무 검사
function fileExists(file) {
  try {
    fs.statSync(file);
    return true;
  } catch (e) {
    return false;
  }
}

var handler = function(request, response) {
//  POST 요청일 경우 BODY에 있는 내용을 파일에 기록 함
  if (request.method == 'POST') {
    var file = fs.createWriteStream(dataFile);
    file.on('open', function (fd) {
      request.pipe(file);
      console.log("New data has been received and stored.");
      response.writeHead(200);
      response.end("Data stored on pod " + os.hostname() + "\n");
    });
// GET 요청일 경우 호스트명과 파일에 기록된 내용을 반환 함
  } else {
    var data = fileExists(dataFile) ? fs.readFileSync(dataFile, 'utf8') : "No data posted yet";
    response.writeHead(200);
    response.write("You've hit " + os.hostname() + "\n");
    response.end("Data stored on this pod: " + data + "\n");
  }
};

var www = http.createServer(handler);
www.listen(port);
</code></pre>
            <h4 id="1012-docker-이미지-만들기">10.1.2 Docker 이미지 만들기</h4>
            <ul>
              <li>Dockerfile 작성</li>
            </ul>
            <pre><code class="language-{dockerfile}">FROM node:7
ADD app.js /app.js
ENTRYPOINT ["node", "app.js"]
</code></pre>
            <ul>
              <li>Docker 이미지 build 및 push</li>
            </ul>
            <pre><code class="language-{bash}">$ docker build dangtong/nodejs:sfs .
$ docker login
$ docker push dangtong/nodejs:sfs
</code></pre>
            <h3 id="102-pvc-생성">10.2 PVC 생성</h3>
            <pre><code class="language-{yaml}">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-standard-retain
provisioner: kubernetes.io/gce-pd
reclaimPolicy: Retain
parameters:
  type: pd-ssd
  zone: asia-northeast1-c
</code></pre>
            <h3 id="103-서비스-및-pod-생성">10.3 서비스 및 Pod 생성</h3>
            <h4 id="1031-로드밸런서-서비스-생성">
              10.3.1 로드밸런서 서비스 생성
            </h4>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
    name: nodesjs-sfs-lb
spec:
    type: LoadBalancer
    ports:
    - port: 80
      targetPort: 8080
    selector:
        app: nodejs-sfs
</code></pre>
            <h4 id="1032-pod-생성">10.3.2 Pod 생성</h4>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: nodejs-sfs
spec:
  selector:
    matchLabels:
      app: nodejs-sfs
  serviceName: nodejs-sfs
  replicas: 2
  template:
    metadata:
      labels:
        app: nodejs-sfs
    spec:
      containers:
      - name: nodejs-sfs
        image: dangtong/nodejs:sfs
        ports:
        - name: http
          containerPort: 8080
        volumeMounts:
        - name: data
          mountPath: /var/data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      resources:
        requests:
          storage: 1Mi
      accessModes:
      - ReadWriteOnce
      storageClassName: sc-standard-retain
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f nodejs-sfs.yaml
</code></pre>
            <pre><code class="language-{bash}">kubectl get svc

NAME                     TYPE           CLUSTER-IP     EXTERNAL-IP    PORT(S)        AGE
service/kubernetes       ClusterIP      10.65.0.1      &lt;none&gt;         443/TCP        7h43m
service/nodesjs-sfs-lb   LoadBalancer   10.65.12.243   34.85.38.158   80:32280/TCP   120m

</code></pre>
            <h3 id="104-서비스-테스트">10.4 서비스 테스트</h3>
            <ul>
              <li>데이터 조회</li>
            </ul>
            <pre><code class="language-{bash}">curl http://34.85.38.158
</code></pre>
            <ul>
              <li>데이터 입력</li>
            </ul>
            <pre><code class="language-{bash}">curl -X POST -d "hi, my name is dangtong-1" 34.85.38.158
curl -X POST -d "hi, my name is dangtong-2" 34.85.38.158
curl -X POST -d "hi, my name is dangtong-3" 34.85.38.158
curl -X POST -d "hi, my name is dangtong-4" 34.85.38.158
</code></pre>
            <blockquote>
              <p>
                데이터 입력을 반복하에 두개 노드 모드에 데이터를 모두 저장
                합니다. 양쪽 노드에 어떤 데이터가 입력 되었는지 기억 하고 다음
                단계로 넘어 갑니다.
              </p>
            </blockquote>
            <h3 id="105-노드-삭제-및-데이터-보존-확인">
              10.5 노드 삭제 및 데이터 보존 확인
            </h3>
            <ul>
              <li>노드 삭제 및 자동 재생성</li>
            </ul>
            <pre><code class="language-{bash}">kubectl delete pod nodejs-sfs-0
</code></pre>
            <p>노드를 삭제 한뒤 노드가 재생성 될때 까지 기다립니다.</p>
            <ul>
              <li>데이터 보존 확인</li>
            </ul>
            <pre><code class="language-{bash}">curl http://34.85.38.158
</code></pre>
            <blockquote>
              <p>
                노드가 삭제 되었다 재생성 되도 기존 디스크를 그대로 유지하는
                것을 볼 수 있습니다. ReclaimPolicy 를 Retain 으로 했기 때문
                입니다.
              </p>
            </blockquote>
            <h2 id="11-리소스-제어">11. 리소스 제어</h2>
            <h3 id="111-부하-발생용-애플리-케이션-작성">
              11.1 부하 발생용 애플리 케이션 작성
            </h3>
            <h4 id="1111-php-애플리-케이션-작성">
              11.1.1 PHP 애플리 케이션 작성
            </h4>
            <p>파일명 : index.php</p>
            <pre><code class="language-{php}">&lt;?php
  $x = 0.0001;
  for ($i = 0; $i &lt;= 1000000; $i++) {
    $x += sqrt($x);
  }
  echo "OK!";
?&gt;
</code></pre>
            <h4 id="1112-도커-이미지-빌드">11.1.2 도커 이미지 빌드</h4>
            <pre><code class="language-{dockerfile}">FROM php:5-apache
ADD index.php /var/www/html/index.php
RUN chmod a+rx index.php
</code></pre>
            <pre><code class="language-{bash}">docker build -t dangtong/php-apache .
docker login
docker push dangtong/php-apache
</code></pre>
            <h3 id="112-포드-및-서비스-만들기">11.2 포드 및 서비스 만들기</h3>
            <h4 id="1221-deployment-로-pod-새성">
              12.2.1 Deployment 로 Pod 새성
            </h4>
            <p>파일명 : php-apache-deploy.yaml</p>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: Deployment
metadata:
  name: php-apache-dp
spec:
  selector:
    matchLabels:
      app: php-apache
  replicas: 1
  template:
    metadata:
      labels:
        app: php-apache
    spec:
      containers:
      - name: php-apache
        image: dangtong/php-apache
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: 500m
          requests:
            cpu: 200m
</code></pre>
            <h4 id="1222-로드밸런서-서비스-작성">
              12.2.2 로드밸런서 서비스 작성
            </h4>
            <p>파일명 : php-apache-svc.yaml</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Service
metadata:
  name: php-apache-lb
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: php-apache
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./php-apache-deploy.yaml
kubectl apply -f ./php-apache-svc.yaml
</code></pre>
            <h3 id="연습-문제">[[연습 문제]]</h3>
            <p>아래 요구 사항에 맞는 deploy 를 구현 하세요</p>
            <ol>
              <li>Deploy name : nginx</li>
              <li>image : nginx</li>
              <li>cpu 200m</li>
              <li>메모리 : 300Mi</li>
              <li>Port : 80</li>
            </ol>
            <h3 id="123-hpa-리소스-생성">12.3 HPA 리소스 생성</h3>
            <h4 id="1231-hpa-리소스-생성">12.3.1 HPA 리소스 생성</h4>
            <pre><code class="language-{bash}">kubectl autoscale deployment php-apache --cpu-percent=50 --min=1 --max=5
</code></pre>
            <h4 id="1232-hpa-리소스-생성-확인">12.3.2 HPA 리소스 생성 확인</h4>
            <pre><code class="language-{bash}">kubectl get hpa
</code></pre>
            <h3 id="124-jmeter-설치-및-구성">12.4 Jmeter 설치 및 구성</h3>
            <h4 id="1241-jmeter-설치를-위00000해-필요한-것들">
              12.4.1 Jmeter 설치를 위00000해 필요한 것들
            </h4>
            <ul>
              <li>
                JDK 1.8 이상 설치
                <a
                  href="https://www.oracle.com/java/technologies/javase-downloads.html"
                  >오라클 java SE jdk 다운로드</a
                >
              </li>
              <li>
                Jmeter 다운로드
                <a href="https://jmeter.apache.org/download_jmeter.cgi"
                  >Jmeter 다운로드</a
                >
              </li>
              <li>
                Jmeter 플러그인 다운로드
                <a href="https://jmeter-plugins.org/install/Install/"
                  >Jmeter-plugin 다운로드</a
                >
                <ul>
                  <li>
                    Plugins-manager.jar 다운로드 하여 jmeter 내에 lib/ext 밑에
                    복사 합니다.
                  </li>
                </ul>
              </li>
            </ul>
            <h4 id="1242-jmeter-를-통한-부하-발생">
              12.4.2 Jmeter 를 통한 부하 발생
            </h4>
            <p><img src="../img/jmeter.png" alt="jmeter" /></p>
            <h4 id="1243-부하-발생후-pod-모니터링">
              12.4.3 부하 발생후 Pod 모니터링
            </h4>
            <pre><code class="language-{bash}">$ kubectl get hpa

$ kubectl top pods

NAME                          CPU(cores)   MEMORY(bytes)
nodejs-sfs-0                  0m           7Mi
nodejs-sfs-1                  0m           7Mi
php-apache-6997577bfc-27r95   1m           9Mi


$ kubectl exec -it nodejs-sfs-0 top

Tasks:   2 total,   1 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu(s):  4.0 us,  1.0 sy,  0.0 ni, 95.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   3786676 total,  3217936 used,   568740 free,   109732 buffers
KiB Swap:        0 total,        0 used,        0 free.  2264392 cached Mem
    PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
      1 root      20   0  813604  25872  19256 S  0.0  0.7   0:00.17 node
     11 root      20   0   21924   2408   2084 R  0.0  0.1   0:00.00 top
</code></pre>
            <h3 id="exercise">[[Exercise]]</h3>
            <p>이미지를 nginx 를 생성하고 HPA 를 적용하세요</p>
            <ul>
              <li>Max : 8</li>
              <li>Min : 2</li>
              <li>CPU 사용량이 40% 가 되면 스케일링 되게 하세요</li>
            </ul>
            <h2 id="13-kubernetes-dashboard-설치">
              13. Kubernetes DashBoard 설치
            </h2>
            <h3 id="131-dashboard-설치">13.1 Dashboard 설치</h3>
            <p>
              참조 URL :
              https://kubernetes.io/ko/docs/tasks/access-application-cluster/web-ui-dashboard/
            </p>
            <pre><code class="language-{bash}">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml
</code></pre>
            <h3 id="132-dashboard-인증서-생성">13.2 DashBoard 인증서 생성</h3>
            <pre><code class="language-{bash}">mkdir -p ./kubeSrc/dashboard/certs
mkdir -p ./kubeSrc/dashboard/yaml

cd ./kubeSrc/dashboard/certs
</code></pre>
            <h4 id="1321-개인키-생성">13.2.1 개인키 생성</h4>
            <pre><code class="language-{bash}">openssl genrsa -des3 -out dashboard-private.key 2048

Generating RSA private key, 2048 bit long modulus (2 primes)
.....................................................................................+++++
...........................................+++++
e is 65537 (0x010001)
Enter pass phrase for dashboard-private.key:
Verifying - Enter pass phrase for dashboard-private.key:



# openssl rsa --noout -text -in dashboard-private.key
</code></pre>
            <h4 id="1321-공개키-생성">13.2.1 공개키 생성</h4>
            <pre><code class="language-{bash}">openssl rsa -in dashboard-private.key -out dashboard-public.key
</code></pre>
            <h4 id="1322-csr-생성">13.2.2 CSR 생성</h4>
            <pre><code class="language-{bash}">openssl req -new -key dashboard-public.key -out dashboard.csr

You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:KR
State or Province Name (full name) [Some-State]:Seoul
Locality Name (eg, city) []:Guro-Gu
Organization Name (eg, company) [Internet Widgits Pty Ltd]:acorn
Organizational Unit Name (eg, section) []:edu
Common Name (e.g. server FQDN or YOUR name) []:*.acorn.com
Email Address []:dangtong@gmail.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:admin123
An optional company name []:acorn
</code></pre>
            <h4 id="1323-인증서-생성">13.2.3 인증서 생성</h4>
            <pre><code class="language-{bash}">openssl x509 -req -sha256 -days 3650 -in dashboard.csr -signkey dashboard-public.key -out kubernetes-dashboard.crt
</code></pre>
            <h3 id="133-dashboard-생성">13.3 DashBoard 생성</h3>
            <h4 id="1331-네임스페이스-및-secret-생성">
              13.3.1 네임스페이스 및 Secret 생성
            </h4>
            <ul>
              <li>네임스페이스 생성</li>
            </ul>
            <pre><code class="language-{bash}">kubectl create namespace kubernetes-dashboard
</code></pre>
            <ul>
              <li>Secret 생성</li>
            </ul>
            <pre><code class="language-{bash}">kubectl create secret generic kubernetes-dashboard-certs --from-file=$HOME/kubeSrc/dashboard/certs -n kubernetes-dashboard
</code></pre>
            <ul>
              <li>Secret 확인</li>
            </ul>
            <pre><code class="language-{bahs}">kubectl get secret -n kubernetes-dashboard-certs -n kubernetes-dashboard
</code></pre>
            <h4 id="1332-dashboard-deployment">13.3.2 DashBoard Deployment</h4>
            <pre><code class="language-{bash}">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml
</code></pre>
            <h4 id="1333-clusterip-를-nodeport-방식으로-변경">
              13.3.3 ClusterIP 를 NodePort 방식으로 변경
            </h4>
            <pre><code class="language-{bash}">kubectl edit service kubernetes-dashboard -n kubernetes-dashboard
</code></pre>
            <pre><code class="language-{yaml}">...
ports:
  - nodePort: 30812 # 이부분 추가
    port: 443
    protocol: TCP
    targetPort: 8443
  selector:
    k8s-app: kubernetes-dashboard
  sessionAffinity: None
  type: NodePort # 이부분 변경

</code></pre>
            <h4 id="1334-서비스-확인">13.3.4 서비스 확인</h4>
            <pre><code class="language-{bash}">kubectl get service -n kubernetes-dashboard
</code></pre>
            <h4 id="132">13.2.</h4>
            <h4 id="132-nodeport-서비스">13.2 NodePort 서비스</h4>
            <pre><code class="language-{yaml}">spec:
  clusterIP: 10.103.46.146
  ports:
  - port: 443
    protocol: TCP
    targetPort: 8443
    nodePort: 30124
  selector:
    k8s-app: kubernetes-dashboard
  sessionAffinity: None
  type: NodePort
status:
  loadBalancer: {}
</code></pre>
            <h3 id="132-client-인증서-만들기">13.2 Client 인증서 만들기</h3>
            <ul>
              <li>kubectl 의 key 복사</li>
            </ul>
            <pre><code class="language-{bash}">grep 'client-key-data' ~/.kube/config | head -n 1 | awk '{print $2}' | base64 -d &gt;&gt; kubecfg.key
</code></pre>
            <ul>
              <li>인증서 생성</li>
            </ul>
            <pre><code class="language-{bash}">
# CSR 생성
openssl req -new -key  kubecfg.key -out kubecfg.csr -subj "/CN=admin-user"

# 인증서 생성
sudo openssl x509 -req -in kubecfg.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out kubecfg.crt -days 500
</code></pre>
            <ul>
              <li>브라우저에서 사용 가능한 PKCS#12 양식으로 변환 합니다</li>
            </ul>
            <pre><code class="language-{bash}">openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name "admin-user"
</code></pre>
            <ul>
              <li>CA 인증서를 복사합니다.</li>
            </ul>
            <pre><code class="language-{bash}">cp /etc/kubernetes/pki/ca.crt .
</code></pre>
            <pre><code class="language-{bash}">kubeadmin@kmaster:~/kubeSrc/dashboard$ ls
ca.crt  kubecfg.crt  kubecfg.csr  kubecfg.key  kubecfg.p12
</code></pre>
            <ul>
              <li>
                Sftp 로 서버에 접속해서 kubecfg.crt / kubecfg.p12 / ca.crt
                파일을 다운로드 받습니다.
              </li>
            </ul>
            <h3 id="133-인증서">13.3 인증서</h3>
            <h4 id="1331-윈도우-인증서-import">13.3.1 윈도우 인증서 Import</h4>
            <ul>
              <li>윈도우 Root CA 인증서 Import</li>
            </ul>
            <pre><code class="language-{cmd}">C:\Windows\system32&gt;certutil.exe -addstore "Root" C:\Users\dangtong\Documents\ca.crt
Root "신뢰할 수 있는 루트 인증 기관"
서명이 공개 키와 일치합니다.
"kubernetes" 인증서가 저장소에 추가되었습니다.
CertUtil: -addstore 명령이 성공적으로 완료되었습니다.
</code></pre>
            <ul>
              <li>PKCS#12 인증서 Imort</li>
            </ul>
            <pre><code class="language-{cmd}">C:\Windows\system32&gt;certutil.exe -p admin123 -user -importPFX
</code></pre>
            <p><img src="../img/cert_capture.PNG" alt="cert_capture" /></p>
            <pre><code class="language-{cmd}">
C:\Users\dangtong\Documents\kubecfg.p12
"kubernetes-admin" 인증서가 저장소에 추가되었습니다.

CertUtil: -importPFX 명령이 성공적으로 완료되었습니다.
</code></pre>
            <h4 id="1332-osx-인증서-import">13.3.2 OSX 인증서 Import</h4>
            <ul>
              <li>Root CA 인증서 Import</li>
            </ul>
            <pre><code class="language-{bash}">security add-trusted-cert  -r trustRoot -k "$HOME/Library/Keychains/login.keychain" /Users/dangtong/kube-dashboard/ca.crt
</code></pre>
            <ul>
              <li>PKCS#12 인증서 Import</li>
            </ul>
            <pre><code class="language-{bash}">security import   /Users/dangtong/kube-dashboard/kubecfg.p12 -k "$HOME/Library/Keychains/login.keychain" -P admin123
</code></pre>
            <h3 id="134-서비스-어카운트-및-롤생성">
              13.4 서비스 어카운트 및 롤생성
            </h3>
            <h4 id="1341-서비스-어카운트-생성">13.4.1 서비스 어카운트 생성</h4>
            <p>파일명 : admin-user.yaml</p>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kubernetes-dashboard
</code></pre>
            <h4 id="1342-롤생성">13.4.2 롤생성</h4>
            <p>파일명 : admin-user-role.yaml</p>
            <pre><code class="language-{yaml}">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user-role-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kubernetes-dashboard
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./admin-user.yaml
kubectl apply -f ./admin-user-role.yaml
</code></pre>
            <h4 id="1343-인증-토큰-조회">13.4.3 인증 토큰 조회</h4>
            <p>아래 명령을 수행해서 인증 토큰을 복사 합니다.</p>
            <pre><code class="language-{bash}">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '{print $1}')

Name:         admin-user-token-28l6n
Namespace:    kubernetes-dashboard
Labels:       &lt;none&gt;
Annotations:  kubernetes.io/service-account.name: admin-user
              kubernetes.io/service-account.uid: d3f6b3d6-63f3-4483-88f0-dc8e6f37ffd8

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  20 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6InEwaS1COEtFcjNwd0RBbE1KUHpaNTZuZlBlSmY4a1Nld1FZYjhIam5ZV2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLTI4bDZuIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJkM2Y2YjNkNi02M2YzLTQ0ODMtODhmMC1kYzhlNmYzN2ZmZDgiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.JB1hGeIxJyU-0VbOmMGcp0b6B758nqGAXhgBFOj9eZMj73h7BNizO4aEiDMsJgH3tvtXRxChUHIMFT0kBeX6i7U-3GYvS_Uw7XNREYdhrYl8PVoPcqcXi7tL1tTrCEj-Rxy7HxyHXGGwb6wJYO11BgzuwCLJWjm-i-G3N3yrzi8KQ7MjWKVPisrxgPna_dKO6LgrCiq6oVO14FFVbwB6IqdiH8jpHrH2GSIKjFCAAziHSoHBLbc6qv5_9hle5CaO6LZxTlZCt4H7drWnUUyVmjz1sqkUZg08EVfewVzZCQXPig6Rj3DTGbFrzg1Zk3h3EBJq4VhjnCYj1ePNDw_-eg
</code></pre>
            <h3 id="135-dashboard-접속">13.5 DashBoard 접속</h3>
            <ul>
              <li>접속 URL</li>
            </ul>
            <p>
              https://192.168.56.111:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
            </p>
            <p>
              <img src="../img/dashboard_login.png" alt="dashboard_login" />
            </p>
            <p>
              <kbd>토큰</kbd> 을 선택하고 복사한 토큰을
              <strong>토큰입력</strong> 란에 붙여넣고
              <strong>로그인</strong> 합니다.
            </p>
            <h3 id="136-삭제">13.6 삭제</h3>
            <pre><code class="language-{bash}">kubectl --namespace kube-system delete deployment,service kubernetes-dashboard
</code></pre>
            <h2 id="14-계정-및-인증">14. 계정 및 인증</h2>
            <h3 id="141-user-account-및-rbac-사용">
              14.1 User Account 및 RBAC 사용
            </h3>
            <h4 id="1411-유저-생성">14.1.1 유저 생성</h4>
            <pre><code class="language-{bash}"># root 로 수행
adduser devuser
su - devuser

# devuser 로 수행
mkdir .cert
mkdir .kube
</code></pre>
            <h4 id="1412-유저-인증서-생성root-로-수행">
              14.1.2 유저 인증서 생성(root 로 수행)
            </h4>
            <ul>
              <li>인증서 생성</li>
            </ul>
            <pre><code class="language-{bash}">cd ~
mkdir devuser-cert
cd devuser-cert

# 키생성
openssl genrsa -out devuser.key 2048

# CSR 생성
openssl req -new -key devuser.key -out devuser.csr -subj "/CN=devuser/O=devuser"

# 인증서 생성
openssl x509 -req -in devuser.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out devuser.crt -days 500
</code></pre>
            <ul>
              <li>인증서 복사</li>
            </ul>
            <pre><code class="language-{bash}">cp devuser.crt /home/devuser/.cert/
cp devuser.key /home/devuser/.cert/
chown -R devuser:devuser /home/devuser/.cert
</code></pre>
            <h4 id="1413-kubectl-로-config-파일-만들기devuser-로-수행">
              14.1.3 kubectl 로 config 파일 만들기(devuser 로 수행)
            </h4>
            <ul>
              <li>API 서버 접속 및 CA 인증서 설정</li>
            </ul>
            <pre><code class="language-{bash}">cd ~/.kube

kubectl config --kubeconfig=config set-cluster devuser-cluster --server=https://192.168.56.111:6443 --certificate-authority=/etc/kubernetes/pki/ca.crt
</code></pre>
            <pre><code class="language-{bash}">cat ~/.kube/config
</code></pre>
            <ul>
              <li>사용자 접속 정보 (인증서 정보 설정)</li>
            </ul>
            <pre><code class="language-{bash}">kubectl config --kubeconfig=config set-credentials devuser --client-certificate=/home/devuser/.cert/devuser.crt --client-key=/home/devuser/.cert/devuser.key
</code></pre>
            <ul>
              <li>컨텍스트 설정</li>
            </ul>
            <pre><code class="language-{bash}">kubectl config --kubeconfig=config set-context devuser-context --cluster=devuser-cluster --namespace=dev --user=devuser
</code></pre>
            <pre><code class="language-{bash}">cat ~/.kube/config
</code></pre>
            <ul>
              <li>테스트</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get pod

The connection to the server localhost:8080 was refused - did you specify the right host or port?

kubectl --context=devuser-context get po

Error from server (Forbidden): pods is forbidden: User "devuser" cannot list resource "pods" in API group "" in the namespace "dev"
</code></pre>
            <blockquote>
              <p>
                메시지가 왜 다른지 생각 해봅시다. config 를 열어서
                current-context: "devuser-context" 로 수정한 후 다시 수행
                합니다.
              </p>
            </blockquote>
            <h4 id="1414-네임스페이스-생성-root-로-수행">
              14.1.4 네임스페이스 생성 (root 로 수행)
            </h4>
            <pre><code class="language-{bash}">kubectl create namespace dev
</code></pre>
            <h4 id="1415-롤생성-root-로-수행">14.1.5 롤생성 (root 로 수행)</h4>
            <p>파일명 : dev-role.yaml</p>
            <pre><code class="language-{yaml}">kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: dev
  name: dev-role
rules:
- apiGroups: ["", "extensions", "apps"]
  resources: ["deployments", "replicasets", "pods"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./dev-role.yaml
</code></pre>
            <table>
              <thead>
                <tr>
                  <th>Verb</th>
                  <th>설명</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>create</td>
                  <td>리소스 생성</td>
                </tr>
                <tr>
                  <td>get</td>
                  <td>리소스 조회</td>
                </tr>
                <tr>
                  <td>list</td>
                  <td>여러건 리소스 동시 조회</td>
                </tr>
                <tr>
                  <td>update</td>
                  <td>리소스 전체 내용 업데이트</td>
                </tr>
                <tr>
                  <td>patch</td>
                  <td>리소스 일부 내용 변경</td>
                </tr>
                <tr>
                  <td>delete</td>
                  <td>단일 리소스 삭제</td>
                </tr>
                <tr>
                  <td>Delete collection</td>
                  <td>여러 리소스 삭제</td>
                </tr>
              </tbody>
            </table>
            <blockquote>
              <p>
                resource 뿐만 아니라 resourceNames 를 지정해서 특정 Pod 나
                리소스에 대한 권한 으로 제한 할 수도 있음
              </p>
            </blockquote>
            <h4 id="1416-롤바인딩-생성-root-로-수행">
              14.1.6 롤바인딩 생성 (root 로 수행)
            </h4>
            <p>파일명 : dev-role-bind.yaml</p>
            <pre><code class="language-{yaml}">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: dev-role-binding
  namespace: dev
subjects:
- kind: User
  name: devuser
  apiGroup: ""
roleRef:
  kind: Role
  name: dev-role
  apiGroup: ""
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./dev-role-bind.yaml
</code></pre>
            <h4 id="1417-테스트-pod-생성-및-테스트-devuser-로-수행">
              14.1.7 테스트 Pod 생성 및 테스트 (devuser 로 수행)
            </h4>
            <pre><code class="language-{bash}"># 사용 가능한 context 확인
kubectl config get-contexts

# context로 전환
kubectl config use-context devuser-context

# 현재 사용중인 context 확인
kubectl config current-context
</code></pre>
            <pre><code class="language-{bash}">kubectl --context=devuser-context run --generator=run-pod/v1 nginx --image=nginx --port=80 --dry-run -o yaml &gt; nginx-pod.yaml
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./nginx-pod.yaml

kubectl get pod -o wide
NAME    READY   STATUS    RESTARTS   AGE     IP          NODE                 NOMINATED NODE   READINESS GATES
nginx   1/1     Running   0          2m39s   10.40.0.8   worker01.acorn.com   &lt;none&gt;           &lt;none&gt;


curl http://10.40.0.8
</code></pre>
            <h3 id="142-service-account-및-rbac">
              14.2 Service Account 및 RBAC
            </h3>
            <h4 id="1421-service-account-생성">14.2.1 Service Account 생성</h4>
            <ul>
              <li>Service Account 생성</li>
            </ul>
            <pre><code class="language-{bash}">kubectl create sa apiuser

# kubectl create sa apiuser --dry-run -o yaml

kubectl get sa

kubectl get sa --all-namespaces
</code></pre>
            <ul>
              <li>토큰 Secret 생성</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: Secret
metadata:
  name: apiuser-secret
  annotations:
    kubernetes.io/service-account.name: apiuser
type: kubernetes.io/service-account-token
</code></pre>
            <pre><code class="language-{bash}">kubectl describe secrets/apiuser-secret
</code></pre>
            <h4 id="1422-롤-생성">14.2.2 롤 생성</h4>
            <ul>
              <li>롤 생성</li>
            </ul>
            <pre><code class="language-{yaml}">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-role
  namespace: default
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
</code></pre>
            <h4 id="1423-롤-바인딩">14.2.3 롤 바인딩</h4>
            <pre><code class="language-{bash}">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-role-binding
  namespace: default
subjects:
- kind: ServiceAccount
  name: apiuser
  apiGroup: ""
roleRef:
  kind: Role
  name: read-role
  apiGroup: kube
</code></pre>
            <h4 id="1424-토큰-인코딩-및-서비스-테스트">
              14.2.4 토큰 인코딩 및 서비스 테스트
            </h4>
            <ul>
              <li>토큰 인코딩</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get secret apiuser-secret -o yaml

apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: "2020-04-30T19:48:15Z"
  name: apiuser
  namespace: default
  resourceVersion: "1715742"
  selfLink: /api/v1/namespaces/default/serviceaccounts/apiuser
  uid: 3b658e4a-ec4f-4eda-b790-ba74d0607973
secrets:
- name: apiuser-token-llvcb  # 토큰
</code></pre>
            <pre><code class="language-{bash}">kubectl get secrets apiuser-token-llvcb -o json | jq -Mr '.data.token' | base64 -d
</code></pre>
            <ul>
              <li>Pod 리스트 조회</li>
            </ul>
            <pre><code class="language-{bash}">curl -k  https://192.168.56.111:6443/api/v1/namespaces/default/pods/  -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6InEwaS1COEtFcjNwd0RBbE1KUHpaNTZuZlBlSmY4a1Nld1FZYjhIam5ZV2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImFwaXVzZXItdG9rZW4tbGx2Y2IiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiYXBpdXNlciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjNiNjU4ZTRhLWVjNGYtNGVkYS1iNzkwLWJhNzRkMDYwNzk3MyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmFwaXVzZXIifQ.qVfF3Tt9fAI6uC8CfyiuSBYnYU8z8sLQIRt3sH0B3zgpcToxPY9aAuoADmg-ULUQJBJjiBgbhWxy1ujpJwKy-jLb-0-MqIype2Z58dlNCOupaWnFDzYMJr9XLL33L6KD7SSVTp22CP89KGj_TxDdOrLj6jQi07WGBBqsliCPu5xy1p6SoiOdl-FxWpHqJxfhgtpVX1ntPA_DN6H_CiFPvvKoaWAy76HzH79aMbdmtR4NDpKYoCo1vbNmnWuQ2571lL4einBKkHj8bi0zeBa1cKvuqTUHftGV4KDYQ0nsX1R7Ispk3XNuMLgx7Lxl6idDUxfDkeRElZraMo3FgMYN0w"
</code></pre>
            <ul>
              <li>특정 Pod 조회</li>
            </ul>
            <pre><code class="language-{bash}">curl -k https://192.168.56.111:6443/api/v1/namespaces/default/pods/goapp-deployment-5857594fbb-46ckf  -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6InEwaS1COEtFcjNwd0RBbE1KUHpaNTZuZlBlSmY4a1Nld1FZYjhIam5ZV2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImFwaXVzZXItdG9rZW4tbGx2Y2IiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiYXBpdXNlciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjNiNjU4ZTRhLWVjNGYtNGVkYS1iNzkwLWJhNzRkMDYwNzk3MyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmFwaXVzZXIifQ.qVfF3Tt9fAI6uC8CfyiuSBYnYU8z8sLQIRt3sH0B3zgpcToxPY9aAuoADmg-ULUQJBJjiBgbhWxy1ujpJwKy-jLb-0-MqIype2Z58dlNCOupaWnFDzYMJr9XLL33L6KD7SSVTp22CP89KGj_TxDdOrLj6jQi07WGBBqsliCPu5xy1p6SoiOdl-FxWpHqJxfhgtpVX1ntPA_DN6H_CiFPvvKoaWAy76HzH79aMbdmtR4NDpKYoCo1vbNmnWuQ2571lL4einBKkHj8bi0zeBa1cKvuqTUHftGV4KDYQ0nsX1R7Ispk3XNuMLgx7Lxl6idDUxfDkeRElZraMo3FgMYN0w"
</code></pre>
            <h3 id="143-클러스터롤-과-집계-클러스터롤">
              14.3 클러스터롤 과 집계 클러스터롤
            </h3>
            <h4 id="1431-클러스터롤-생성">14.3.1 클러스터롤 생성</h4>
            <pre><code class="language-{bash}">vi read-clusterrole.yaml
</code></pre>
            <pre><code class="language-{yaml}">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-cluster-role
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
</code></pre>
            <h4 id="1423-aggregation-클러스터룰-생성">
              14.2.3 Aggregation 클러스터룰 생성
            </h4>
            <ul>
              <li>생성</li>
            </ul>
            <pre><code class="language-{bash}">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: agg-cluster-role
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      kubernetes.io/bootstrapping: rbac-defaults
rules: []
</code></pre>
            <ul>
              <li>확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get clusterrole cluster-admin -o yaml

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  creationTimestamp: "2020-04-30T06:02:28Z"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: cluster-admin
  resourceVersion: "38"
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterroles/cluster-admin
</code></pre>
            <h4 id="1423-롤바인딩">14.2.3 롤바인딩</h4>
            <ul>
              <li>테스트용 유저 생성</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: v1
kind: ServiceAccount
metadata:
  name: myuser
  namespace: default
</code></pre>
            <ul>
              <li>클러스터롤 바인딩</li>
            </ul>
            <pre><code class="language-{yaml}">kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-cluster-role-binding
subjects:
- kind: ServiceAccount
  name: myuser
  namespace: default
  apiGroup: ""
roleRef:
  kind: ClusterRole
  name: read-cluster-role  # 미리 만든 클러스터롤을 유저에 바인딩 합니다
  apiGroup: rbac.authorization.k8s.io
</code></pre>
            <ul>
              <li>Aggregation 클러스터 롤 바인딩</li>
            </ul>
            <pre><code class="language-{yaml}">kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: agg-cluster-role-binding
subjects:
- kind: ServiceAccount
  name: myuser
  namespace: default
  apiGroup: ""
roleRef:
  kind: ClusterRole
  name: agg-cluster-role  # 미리 만든 클러스터롤을 유저에 바인딩 합니다
  apiGroup: rbac.authorization.k8s.io
</code></pre>
            <h2 id="15-테인트taint-와-톨러레이션tolerations">
              15. 테인트(Taint) 와 톨러레이션(Tolerations)
            </h2>
            <ul>
              <li>
                tain : 노드마다 설정 가능 하며, 설정한 노드에는 Pod 가 스케줄
                되지 않음
              </li>
              <li>Toleration: taint를 무시 할 수 있음</li>
              <li>Taint 에는 3가지 종류가 있음</li>
            </ul>
            <table>
              <thead>
                <tr>
                  <th>Taint</th>
                  <th>설명</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>NoSchedule</td>
                  <td>
                    toleration이 없으면 pod이 스케쥴되지 않음, 기존 실행되던
                    pod에는 적용 안됨
                  </td>
                </tr>
                <tr>
                  <td>PreferNoSchedule</td>
                  <td>
                    toleration이 없으면 pod을 스케줄링안하려고 하지만 필수는
                    아님, 클러스터내에 자원이 부족하거나 하면 taint가 걸려있는
                    노드에서도 pod이 스케줄링될 수 있음
                  </td>
                </tr>
                <tr>
                  <td>NoExecute</td>
                  <td>
                    toleration이 없으면 pod이 스케줄되지 않으며 기존에 실행되던
                    pod도 toleration이 없으면 종료시킴.
                  </td>
                </tr>
              </tbody>
            </table>
            <h3 id="151-노드에-taint-설정하기">15.1 노드에 Taint 설정하기</h3>
            <h4 id="1511-taint-설정">15.1.1 Taint 설정</h4>
            <pre><code class="language-{bash}">kubectl taint node worker01.acorn.com key=value1:NoSchedule
</code></pre>
            <h4 id="1512-taint-조회">15.1.2 Taint 조회</h4>
            <pre><code class="language-{bash}">kubectl describe node worker01.acorn.com

node/worker01.acorn.com tainted
root@master:~# kubectl describe node worker01.acorn.com
Name:               worker01.acorn.com
Roles:              &lt;none&gt;
Labels:             beta.kubernetes.io/arch=amd64
                    beta.kubernetes.io/os=linux
                    disk=ssd
                    kubernetes.io/arch=amd64
                    kubernetes.io/hostname=worker01.acorn.com
                    kubernetes.io/os=linux
Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                    node.alpha.kubernetes.io/ttl: 0
                    volumes.kubernetes.io/controller-managed-attach-detach: true
CreationTimestamp:  Wed, 18 Mar 2020 15:48:26 +0000
Taints:             key=value1:NoSchedule
Unschedulable:      false
Lease:
  HolderIdentity:  worker01.acorn.com
</code></pre>
            <h3 id="152-daemonset-생성">15.2 DaemonSet 생성</h3>
            <h4 id="1521-yaml-파일-작성">15.2.1 Yaml 파일 작성</h4>
            <p>파일명 : goapp-daemon.yaml</p>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: goapp-damonset
spec:
  selector:
    matchLabels:
      app: goapp-pod
  template:
    metadata:
      labels:
        app: goapp-pod
    spec:
      containers:
      - name: goapp-container
        image: dangtong/goapp
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./goapp-daemon.yaml
</code></pre>
            <h4 id="1522-daemonset-생성-확인">15.2.2 DaemonSet 생성 확인</h4>
            <pre><code class="language-{bash}">kubectl get po -o wide

NAME                   READY   STATUS    RESTARTS   AGE   IP          NODE                 NOMINATED NODE   READINESS GATES
goapp-damonset-bmwfq   1/1     Running   0          18s   10.38.0.3   worker02.acorn.com   &lt;none&gt;           &lt;none&gt;
</code></pre>
            <blockquote>
              <p>Master 노드와 worker01 에는 스케줄링 되지 않았습니다.</p>
            </blockquote>
            <ul>
              <li>master 노드의 taint 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl describe node master.acorn.com | grep -i taint

Taints:             node-role.kubernetes.io/master:NoSchedule
</code></pre>
            <ul>
              <li>worker01 노드의 Taint 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl describe node worker01.acorn.com | grep -i taint

Taints:             key=value1:NoSchedule
</code></pre>
            <ul>
              <li>DaemonSet 삭제</li>
            </ul>
            <pre><code class="language-{bash}">kubectl delete ds goapp-damonset
</code></pre>
            <h3 id="1523-toleration-을-적용한-daemonset-생성">
              15.2.3 Toleration 을 적용한 DaemonSet 생성
            </h3>
            <ul>
              <li>Yaml 파일 작성 : goal-daemon-toler.yaml</li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: goapp-damonset
spec:
  selector:
    matchLabels:
      app: goapp-pod
  template:
    metadata:
      labels:
        app: goapp-pod
    spec:
      tolerations:
      - key: key
        operator: Equal
        value: value1
        effect: NoSchedule
      containers:
      - name: goapp-container
        image: dangtong/goapp
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./goapp-daemon-toler.yaml
</code></pre>
            <ul>
              <li>DaemonSet 생성 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get po -o wide

NAME                   READY   STATUS    RESTARTS   AGE   IP          NODE                 NOMINATED NODE   READINESS GATES
goapp-damonset-74klq   1/1     Running   0          35s   10.38.0.3   worker02.acorn.com   &lt;none&gt;           &lt;none&gt;
goapp-damonset-dr4xz   1/1     Running   0          35s   10.40.0.2   worker01.acorn.com   &lt;none&gt;           &lt;none&gt;
</code></pre>
            <blockquote>
              <p>
                Pod 가 Taint 를 무시하고 worker01 에도 생성 된것을 확인 할 수
                있습니다.
              </p>
            </blockquote>
            <ul>
              <li>다음 테스트를 위해 DaemonSet 삭제</li>
            </ul>
            <pre><code class="language-{bash}">kubectl delete ds goapp-damonset
</code></pre>
            <ul>
              <li>Mater 노드에도 DaemonSet 생성을 위해 Yaml 파일 수정</li>
            </ul>
            <pre><code class="language-{bash}">kubectl describe no master.acorn.com | grep -i taint

Taints:             node-role.kubernetes.io/master:NoSchedule
</code></pre>
            <blockquote>
              <p>master 노드의 Taint 에는 key 와 effect 만 존재함</p>
            </blockquote>
            <ul>
              <li>
                Master 노드에 스케줄링이 가능 하도록 Yaml 파일 작성 :
                goapp-damon-toler-all.yaml
              </li>
            </ul>
            <pre><code class="language-{yaml}">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: goapp-damonset
spec:
  selector:
    matchLabels:
      app: goapp-pod
  template:
    metadata:
      labels:
        app: goapp-pod
    spec:
      tolerations:
      - key: key
        operator: Equal
        value: value1
        effect: NoSchedule
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      containers:
      - name: goapp-container
        image: dangtong/goapp
</code></pre>
            <pre><code class="language-{bash}">kubectl apply -f ./goapp-daemon-toler-all.yaml
</code></pre>
            <ul>
              <li>다음 테스트를 위해 DaemonSet 삭제</li>
            </ul>
            <pre><code class="language-{bash}">kubectl delete ds goapp-daemonset
</code></pre>
            <h3 id="1524-untaint-명령으로-노드의-taint-해지하고-스케줄링-하기">
              15.2.4 untaint 명령으로 노드의 Taint 해지하고 스케줄링 하기
            </h3>
            <ul>
              <li>Untaint 설정 하기</li>
            </ul>
            <pre><code class="language-{bash}">kubectl describe no worker01.acorn.com | grep -i taint

Taints:             key=value1:NoSchedule
</code></pre>
            <pre><code class="language-{bash}">kubectl taint nodes --all key-
</code></pre>
            <blockquote>
              <p>키값 뒤에 "-" 를 붙여 taint 를 해지 합니다. (untaint)</p>
            </blockquote>
            <ul>
              <li>daemonSet yaml 파일 재수행</li>
            </ul>
            <pre><code class="language-{bash}">kubectl apply -f ./goapp-daemonset.yaml
</code></pre>
            <ul>
              <li>확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get po -o wide

NAME                   READY   STATUS    RESTARTS   AGE   IP          NODE                 NOMINATED NODE   READINESS GATES
goapp-damonset-lj2z7   1/1     Running   0          14s   10.40.0.2   worker01.acorn.com   &lt;none&gt;           &lt;none&gt;
goapp-damonset-vhlq2   1/1     Running   0          15s   10.38.0.3   worker02.acorn.com   &lt;none&gt;           &lt;none&gt;
</code></pre>
            <h2 id="16-노드-패치및-업그레이드를-위한-cordon-과-drain-사용하기">
              16. 노드 패치및 업그레이드를 위한 Cordon 과 Drain 사용하기
            </h2>
            <h3 id="161-cordon-사용하기">16.1 Cordon 사용하기</h3>
            <pre><code class="language-{bash}">kubectl get nodes

NAME                                       STATUS   ROLES    AGE   VERSION
gke-cluster-1-default-pool-20e07d73-4ksw   Ready    &lt;none&gt;   28h   v1.14.10-gke.27
gke-cluster-1-default-pool-20e07d73-6mr8   Ready    &lt;none&gt;   28h   v1.14.10-gke.27
gke-cluster-1-default-pool-20e07d73-8q3g   Ready    &lt;none&gt;   28h   v1.14.10-gke.27
</code></pre>
            <ul>
              <li>cordon 설정</li>
            </ul>
            <pre><code class="language-{bash}">kubectl cordon gke-cluster-1-default-pool-20e07d73-6mr8
</code></pre>
            <pre><code class="language-{bash}">kubectl get nodes

NAME                                       STATUS                     ROLES    AGE   VERSION
gke-cluster-1-default-pool-20e07d73-4ksw   Ready                      &lt;none&gt;   28h   v1.14.10-gke.27
gke-cluster-1-default-pool-20e07d73-6mr8   Ready,SchedulingDisabled   &lt;none&gt;   28h   v1.14.10-gke.27
gke-cluster-1-default-pool-20e07d73-8q3g   Ready                      &lt;none&gt;   28h   v1.14.10-gke.27
</code></pre>
            <ul>
              <li>실제로 스케줄링 되지 않는지 확인해보기</li>
            </ul>
            <pre><code class="language-{bash}">kubectl run nginx --image=nginx:1.7.8 --replicas=4 --port=80
</code></pre>
            <ul>
              <li>스케줄링 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get po -o wide

NAME                     READY   STATUS    RESTARTS   AGE   IP          NODE
   NOMINATED NODE   READINESS GATES
nginx-84569d7db5-cgf95   1/1     Running   0          9s    10.4.0.17   gke-cluster-1-default-pool-20e07d73-8q3g
   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-d7cgg   1/1     Running   0          8s    10.4.1.8    gke-cluster-1-default-pool-20e07d73-4ksw
   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-gnbnq   1/1     Running   0          9s    10.4.1.9    gke-cluster-1-default-pool-20e07d73-4ksw
   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-xqn7b   1/1     Running   0          9s    10.4.0.16   gke-cluster-1-default-pool-20e07d73-8q3g
   &lt;none&gt;           &lt;none&gt;
</code></pre>
            <ul>
              <li>uncodon 설정</li>
            </ul>
            <pre><code class="language-{bash}">kubectl uncordon gke-cluster-1-default-pool-20e07d73-6mr8
</code></pre>
            <pre><code class="language-{bash}">kubectl get nodes
</code></pre>
            <h3 id="162-drain-사용하기">16.2 Drain 사용하기</h3>
            <ul>
              <li>Drain 설정</li>
            </ul>
            <pre><code class="language-{bash}">kubeclt get po -o wide

NAME                     READY   STATUS    RESTARTS   AGE     IP          NODE
     NOMINATED NODE   READINESS GATES
nginx-84569d7db5-cgf95   1/1     Running   0          3m44s   10.4.0.17   gke-cluster-1-default-pool-20e07d73-8q
3g   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-d7cgg   1/1     Running   0          3m43s   10.4.1.8    gke-cluster-1-default-pool-20e07d73-4k
sw   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-gnbnq   1/1     Running   0          3m44s   10.4.1.9    gke-cluster-1-default-pool-20e07d73-4k
sw   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-xqn7b   1/1     Running   0          3m44s   10.4.0.16   gke-cluster-1-default-pool-20e07d73-8q
3g   &lt;none&gt;           &lt;none&gt;
</code></pre>
            <ul>
              <li>Pod 가 존재 하는 노드를 drain 모드로 설정하기</li>
            </ul>
            <pre><code class="language-{bash}">kubectl drain gke-cluster-1-default-pool-20e07d73-8q3g

error: unable to drain node "gke-cluster-1-default-pool-20e07d73-8q3g", aborting command...
There are pending nodes to be drained:
 gke-cluster-1-default-pool-20e07d73-8q3g
error: cannot delete DaemonSet-managed Pods (use --ignore-daemonsets to ignore): kube-system/fluentd-gcp-v3.1.1-
t6mnn, kube-system/prometheus-to-sd-96fdn
</code></pre>
            <ul>
              <li>
                daemonset 이 존재 하는 노드일 경우 옵션 추가 해서 drain 시킴
              </li>
            </ul>
            <pre><code class="language-{bash}">kubectl drain gke-cluster-1-default-pool-20e07d73-8q3g --ignore-daemonsets
</code></pre>
            <ul>
              <li>drian 확인</li>
            </ul>
            <pre><code class="language-{bash}">kubectl get po -o wide

NAME                     READY   STATUS    RESTARTS   AGE     IP         NODE
    NOMINATED NODE   READINESS GATES
nginx-84569d7db5-8qrd2   1/1     Running   0          59s     10.4.2.7   gke-cluster-1-default-pool-20e07d73-6mr
8   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-d7cgg   1/1     Running   0          8m20s   10.4.1.8   gke-cluster-1-default-pool-20e07d73-4ks
w   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-gnbnq   1/1     Running   0          8m21s   10.4.1.9   gke-cluster-1-default-pool-20e07d73-4ks
w   &lt;none&gt;           &lt;none&gt;
nginx-84569d7db5-s6xsm   1/1     Running   0          59s     10.4.2.9   gke-cluster-1-default-pool-20e07d73-6mr
8   &lt;none&gt;           &lt;none&gt;
</code></pre>
            <blockquote>
              <p>–delete-local-data –force 등의 추가 옵션 있음</p>
            </blockquote>
            <ul>
              <li>uncordon</li>
            </ul>
            <pre><code class="language-{bash}">kubectl drain gke-cluster-1-default-pool-20e07d73-8q3g
</code></pre>
            <h2 id="17-helm-차트-구성-및-사용gcp-에서-수행">
              17. Helm 차트 구성 및 사용(GCP 에서 수행)
            </h2>
            <h3 id="171-helm-차트-다운로드-및-설치">
              17.1 Helm 차트 다운로드 및 설치
            </h3>
            <ul>
              <li>다운로드</li>
            </ul>
            <pre><code class="language-{bash}">curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3

chmod 700 get_helm.sh

./get_helm.sh

Downloading https://get.helm.sh/helm-v3.2.0-linux-amd64.tar.gz
Preparing to install helm into /usr/local/bin
helm installed into /usr/local/bin/helm
</code></pre>
            <ul>
              <li>버전 확인</li>
            </ul>
            <pre><code class="language-{bash}">helm version

version.BuildInfo{Version:"v3.2.0", GitCommit:"e11b7ce3b12db2941e90399e874513fbd24bcb71", GitTreeState:"clean", GoVersion:"go1.13.10"}
</code></pre>
            <ul>
              <li>helm 차트 리포지토리 추가</li>
            </ul>
            <pre><code class="language-{bash}">helm repo add stable https://kubernetes-charts.storage.googleapis.com/
</code></pre>
            <ul>
              <li>리포지토리 업데이트</li>
            </ul>
            <pre><code class="language-{bash}">helm repo update

Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "stable" chart repository
Update Complete. ⎈ Happy Helming!⎈
</code></pre>
            <h3 id="172-mysql-helm-차트-다운로드-및-구성">
              17.2 mysql Helm 차트 다운로드 및 구성
            </h3>
            <ul>
              <li>mysql helm 검색</li>
            </ul>
            <pre><code class="language-{bash}">helm search repo stable/mysql

NAME            	CHART VERSION	APP VERSION	DESCRIPTION
stable/mysql    	1.6.3        	5.7.28     	Fast, reliable, scalable, and easy to use open-...
stable/mysqldump	2.6.0        	2.4.1      	A Helm chart to help backup MySQL databases usi...
</code></pre>
            <ul>
              <li>피키지 메타 정보 보기</li>
            </ul>
            <pre><code class="language-{bash}">helm show chart stable/mysql

apiVersion: v1
appVersion: 5.7.28
description: Fast, reliable, scalable, and easy to use open-source relational database
  system.
home: https://www.mysql.com/
icon: https://www.mysql.com/common/logos/logo-mysql-170x115.png
keywords:
- mysql
- database
- sql
maintainers:
- email: o.with@sportradar.com
  name: olemarkus
- email: viglesias@google.com
  name: viglesiasce
name: mysql
sources:
- https://github.com/kubernetes/charts
- https://github.com/docker-library/mysql
version: 1.6.3
</code></pre>
            <ul>
              <li>mysql helm 차트 설치 및 Deployment</li>
            </ul>
            <pre><code class="language-{bash}">helm install stable/mysql --generate-name

AME: mysql-1588321002
LAST DEPLOYED: Fri May  1 08:16:55 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
MySQL can be accessed via port 3306 on the following DNS name from within your cluster:
mysql-1588321002.default.svc.cluster.local

To get your root password run:

    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default mysql-1588321701 -o jsonpath="{.data.mysql-root-password}" | base64 --decode; echo)

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il

2. Install the mysql client:

    $ apt-get update &amp;&amp; apt-get install mysql-client -y

3. Connect using the mysql cli, then provide your password:
    $ mysql -h mysql-1588321701 -p

To connect to your database directly from outside the K8s cluster:
    MYSQL_HOST=127.0.0.1
    MYSQL_PORT=3306

    # Execute the following command to route the connection:
    kubectl port-forward svc/mysql-1588321002 3306

    mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD}
</code></pre>
            <pre><code class="language-{bash}">helm ls

NAME                    NAMESPACE       REVISION        UPDATED                                 STATUS         C
HART            APP VERSION
mysql-1588321701        default         1               2020-05-01 17:28:25.322363879 +0900 +09 deployed       m
ysql-1.6.3      5.7.28
</code></pre>
            <ul>
              <li>helm 차스 uninstall</li>
            </ul>
            <pre><code class="language-{bash}">heml list

NAME                    NAMESPACE       REVISION        UPDATED                                 STATUS         C
HART            APP VERSION
mysql-1588321701        default         1               2020-05-01 17:28:25.322363879 +0900 +09 deployed       m
ysql-1.6.3      5.7.28


helm uninstall mysql-1588321701
release "mysql-1588321701" uninstalled
</code></pre>
            <h2 id="istio-구성-하기">Istio 구성 하기</h2>
            <h2 id="20-최종-연습문제">20. 최종 연습문제</h2>
            <h3 id="201-php-guestbook-with-redis">
              20.1 PHP GuestBook with Redis
            </h3>
            <h4 id="2011-과제-개요">20.1.1 과제 개요</h4>
            <ul>
              <li>레디스 마스터 구성</li>
              <li>레디스 슬레이브 구성</li>
              <li>Guestbook 프론트앤드 구성</li>
              <li>프로트앤드 애플리케이션 서비스로 노출 시키기</li>
              <li>삭제</li>
            </ul>
            <h4 id="2012-레디스-마스터-deployment-로-구성">
              20.1.2 레디스 마스터 Deployment 로 구성
            </h4>
            <table>
              <thead>
                <tr>
                  <th>항목</th>
                  <th>값</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>파일명</td>
                  <td>redis-master-deployment.yaml</td>
                </tr>
                <tr>
                  <td>Deployment name</td>
                  <td>redis-master</td>
                </tr>
                <tr>
                  <td>Deployment Label</td>
                  <td>app: redis</td>
                </tr>
                <tr>
                  <td>deployment Selector / pod metadata</td>
                  <td>app: redis / role: master / tier: backend</td>
                </tr>
                <tr>
                  <td>replica</td>
                  <td>1</td>
                </tr>
                <tr>
                  <td>Image</td>
                  <td>k8s.gcr.io/redis:e2e</td>
                </tr>
                <tr>
                  <td>Port</td>
                  <td>6379</td>
                </tr>
              </tbody>
            </table>
            <blockquote><p>kubectl logs -f POD-NAME</p></blockquote>
            <h4 id="2013-레디스-마스터-서비스-구성">
              20.1.3 레디스 마스터 서비스 구성
            </h4>
            <table>
              <thead>
                <tr>
                  <th>항목</th>
                  <th>값</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Type</td>
                  <td>ClusterIP</td>
                </tr>
                <tr>
                  <td>Service 이름</td>
                  <td>redis-master</td>
                </tr>
                <tr>
                  <td>Service Label</td>
                  <td>app: redis / role: master / tier: backend</td>
                </tr>
                <tr>
                  <td>port / targetPort</td>
                  <td>6379 / 6379</td>
                </tr>
                <tr>
                  <td>selector</td>
                  <td>app: redis / role: master / tier: backend</td>
                </tr>
              </tbody>
            </table>
            <h4 id="2014-레디스-슬레이브-deployment-구성">
              20.1.4 레디스 슬레이브 Deployment 구성
            </h4>
            <table>
              <thead>
                <tr>
                  <th>항목</th>
                  <th>값</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>파일명</td>
                  <td>redis-slave-deployment.yaml</td>
                </tr>
                <tr>
                  <td>Deployment Name</td>
                  <td>redis-slave</td>
                </tr>
                <tr>
                  <td>Deployment Label</td>
                  <td>app: redis</td>
                </tr>
                <tr>
                  <td>Deployment matchLabel</td>
                  <td>app: redis / role: slave / tier: backend</td>
                </tr>
                <tr>
                  <td>Replicas : 2</td>
                  <td> </td>
                </tr>
                <tr>
                  <td>Pod Label</td>
                  <td>app: redis / role: slave / tier: backend</td>
                </tr>
                <tr>
                  <td>Container name</td>
                  <td>slave</td>
                </tr>
                <tr>
                  <td>Image</td>
                  <td>gcr.io/google_samples/gb-redisslave:v3</td>
                </tr>
                <tr>
                  <td>환경변수 : GET_HOSTS_FROM</td>
                  <td>마스터 노드의 주소로 지정 하되 value=dns 로 설정</td>
                </tr>
                <tr>
                  <td>containerPort</td>
                  <td>6379</td>
                </tr>
              </tbody>
            </table>
            <ul>
              <li>
                아래와 같이 소스 코드를 보면 GET_HOSTS_FROM 에는 master 의
                주소가 들어가야함
              </li>
            </ul>
            <pre><code class="language-{php}"> $host = 'redis-master';
  if (getenv('GET_HOSTS_FROM') == 'env') {
    $host = getenv('REDIS_MASTER_SERVICE_HOST');
  }
</code></pre>
            <h4 id="2015-레디스-슬레이브-서비스-구성">
              20.1.5 레디스 슬레이브 서비스 구성
            </h4>
            <table>
              <thead>
                <tr>
                  <th>항목</th>
                  <th>값</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Type</td>
                  <td>ClusterIP</td>
                </tr>
                <tr>
                  <td>Service 이름</td>
                  <td>redis-slave</td>
                </tr>
                <tr>
                  <td>Service Label</td>
                  <td>app: redis / role: slave / tier: backend</td>
                </tr>
                <tr>
                  <td>port / targetPort</td>
                  <td>6379 / 6379</td>
                </tr>
                <tr>
                  <td>selector</td>
                  <td>app: redis / role: slaver / tier: backend</td>
                </tr>
              </tbody>
            </table>
            <h4 id="2016-guestbook-애플리케이션-deployment-생성">
              20.1.6 GuestBook 애플리케이션 Deployment 생성
            </h4>
            <table>
              <thead>
                <tr>
                  <th>항목</th>
                  <th>값</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>파일명</td>
                  <td>frontend-deployment.yaml</td>
                </tr>
                <tr>
                  <td>Deployment Name</td>
                  <td>frontend</td>
                </tr>
                <tr>
                  <td>Deployment Label</td>
                  <td>app: guestbook</td>
                </tr>
                <tr>
                  <td>Deployment matchLabel</td>
                  <td>app: guestbook / tier: frontend</td>
                </tr>
                <tr>
                  <td>Replicas : 3</td>
                  <td> </td>
                </tr>
                <tr>
                  <td>Pod Label</td>
                  <td>app: guestbook / tier: frontend</td>
                </tr>
                <tr>
                  <td>Container name</td>
                  <td>php-redis</td>
                </tr>
                <tr>
                  <td>Image</td>
                  <td>gcr.io/google-samples/gb-frontend:v4</td>
                </tr>
                <tr>
                  <td>환경변수 : GET_HOSTS_FROM</td>
                  <td>마스터 노드의 주소로 지정 하되 value=dns 로 설정</td>
                </tr>
                <tr>
                  <td>containerPort</td>
                  <td>80</td>
                </tr>
              </tbody>
            </table>
            <h4 id="2017-guestbook-애플리케이션-loadbalancer-서비스-구성">
              20.1.7 GuestBook 애플리케이션 LoadBalancer 서비스 구성
            </h4>
            <table>
              <thead>
                <tr>
                  <th>항목</th>
                  <th>값</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Service name</td>
                  <td>frontend</td>
                </tr>
                <tr>
                  <td>service Label</td>
                  <td>app: guestbook / tier: frontend</td>
                </tr>
                <tr>
                  <td>Type</td>
                  <td>LoadBalancer</td>
                </tr>
                <tr>
                  <td>Port</td>
                  <td>80</td>
                </tr>
                <tr>
                  <td>selector</td>
                  <td>app: guestbook / tier: frontend</td>
                </tr>
              </tbody>
            </table>
            <h4 id="2018-frontend-앱-스케일링-해보기">
              20.1.8 FrontEnd 앱 스케일링 해보기
            </h4>
            <p>replica 를 5개로 스케일링 해보기</p>
            <h2 id="21-kata-연습-문제">21. Kata 연습 문제</h2>
            <p>####</p>
            <h4 id="1-단일-pod-생성">1. 단일 Pod 생성</h4>
            <p>
              prodnamespace 라는 이름으로 네임스페이스를 만들고 해당
              네임스페이스 내에 nginx 단일 Pod 를 생성하세요 (명령어로)
            </p>
            <pre><code class="language-{bash}">kubectl create namespace prodnamespace
kubectl run nginx --image=nginx  -n prodnamespace
</code></pre>
            <h4 id="2-명령어-이용-다중-pod-생성">
              2. 명령어 이용 다중 Pod 생성
            </h4>
            <p>
              nginx:1.7.9 이미지로 복제본이 2개이고 컨테이너 포트가 80으로
              개방된 nginx 라는 이름의 Deployment 를 생성 하세요
            </p>
            <pre><code class="language-{bash}">kubectl run nginx-deployment --image=nginx:1.7.8 --replicas=2 --port=80
</code></pre>
            <h5 id="21-하나의-pod-를-선택해서-yaml-파일을-출력하세요">
              2.1 하나의 Pod 를 선택해서 yaml 파일을 출력하세요
            </h5>
            <pre><code class="language-{bash}">kubectl get po

kubectl get po nginx-8bfd472d32-gjzp8 -o yaml
</code></pre>
            <h5
              id="22-nginx-이미지를-179-로-업데이트-하고-업데이트-내용의-이력을-남기세요-record"
            >
              2.2 nginx 이미지를 1.7.9 로 업데이트 하고, 업데이트 내용의 이력을
              남기세요 (–record)
            </h5>
            <pre><code class="language-{bash}">kubectl set image deploy nginx-deployment nginx-deployment=nginx:1.7.9 --record

혹은

kubectl edit deploy nginx-deloyment
</code></pre>
            <h5
              id="23-nginx-179-에서-에러가-발생-했다고-가정하고-rollback-하세요"
            >
              2.3 nginx 1.7.9 에서 에러가 발생 했다고 가정하고 rollback 하세요
            </h5>
            <pre><code class="language-{bash}">kubectl rollout undo deployment/nginx-deployment
</code></pre>
            <h5 id="24-rollout-히스토리를-확인-하세요">
              2.4 rollout 히스토리를 확인 하세요
            </h5>
            <pre><code class="language-{bash}">kubectl rollout history deployment/nginx-deployment
</code></pre>
            <h5 id="25-rivision-번호를-이용해-179-로-rollout-undo-하세요">
              2.5 rivision 번호를 이용해 1.7.9 로 rollout undo 하세요
            </h5>
            <pre><code class="language-{bash}">kubectl rollout undo deployment/nginx-deployment --to-revision=2
</code></pre>
            <h5 id="26-nginx-pod-에-appv1-이라는-라벨을-입력-하세요">
              2.6 nginx Pod 에 app=v1 이라는 라벨을 입력 하세요
            </h5>
            <pre><code class="language-{bash}">kubectl label deploy nginx-deployment app=v1
</code></pre>
            <h4 id="3-bgdblue-green-deployment-구현하기">
              3. BGD(Blue Green Deployment) 구현하기
            </h4>
            <h5 id="31-nginx-앱을-로드밸런싱-해줄-loadbalancer-를-구현-하세요">
              3.1 nginx 앱을 로드밸런싱 해줄 Loadbalancer 를 구현 하세요
            </h5>
            <pre><code class="language-{bash}">apiVersion: v1
kind: Service
metadata:
  name: nginx-lb
spec:
  selector:
    app: v1
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer
</code></pre>
            <h5
              id="32-nginx-의-loadbalancer-external-ip-를-확인하고-curl-명령어로-테스트-해보세요"
            >
              3.2 nginx 의 Loadbalancer External-IP 를 확인하고 curl 명령어로
              테스트 해보세요
            </h5>
            <pre><code class="language-{bash}">kubectl get svc

NAME         TYPE           CLUSTER-IP   EXTERNAL-IP      PORT(S)        AGE
kubernetes   ClusterIP      10.8.0.1     &lt;none&gt;           443/TCP        30h
nginx-lb     LoadBalancer   10.8.7.22    35.184.195.100   80:30833/TCP   38s
</code></pre>
            <pre><code class="language-{bash}">curl http://35.184.195.100
</code></pre>
            <h1 id="appendix">Appendix</h1>
            <h2 id="appendix-0-virtualbox-이미지-구성">
              Appendix 0. VirtualBox 이미지 구성
            </h2>
            <h3 id="1-virtualbox-다운로드-및-설치">
              1. VirtualBox 다운로드 및 설치
            </h3>
            <p>
              다운로드 :
              <a href="https://www.virtualbox.org/wiki/Downloads"
                >https://www.virtualbox.org/wiki/Downloads</a
              >
            </p>
            <p>
              <img
                src="/kubernetes/img/virtualbox-down-3549200.png"
                alt="virtualbox-down"
              />
            </p>
            <h3 id="2-가상-이미지-가져오기">2. 가상 이미지 가져오기</h3>
            <ul>
              <li>구글 드라이버 URL</li>
            </ul>
            <p>
              https://drive.google.com/open?id=1qAv-FyIWbQVIxNn3MKfjIwbVdvo4rxVl
            </p>
            <h3 id="3-가상-이미지-가져오기">3. 가상 이미지 가져오기</h3>
            <p>
              버추얼 박스 실행 후에 <kbd> 파일 </kbd> &gt;
              <kbd>가상이미지 가져오기</kbd> 클릭
            </p>
            <p>
              <img
                src="../../sas_book/img/vbox-choose-image.png"
                alt="vbox-choose-image"
              />
            </p>
            <h3 id="4-vm-설정hisotyr">4. VM 설정hisotyr</h3>
            <p>vm 이름, CPU 개수, MAC 주소 정책 을 아래와 같이 수정 합니다.</p>
            <p>
              <img src="/kubernetes/img/vbox-config.png" alt="vbox-config" />
            </p>
            <h3 id="5-vm-복제">5. VM 복제</h3>
            <p>오른쪽마우스 -&gt; 복제 클릭</p>
            <p><img src="/kubernetes/img/vbox-copy.png" alt="vbox-copy" /></p>
            <p>VM이름 및 MAC주소정책 변경 후 <kbd> 복제 </kbd> 클릭</p>
            <p>
              <img
                src="/kubernetes/img/vbox-copy-config.png"
                alt="vbox-copy-config"
              />
            </p>
            <p>
              동일한 방법으로 worker02 VM 또 생성 합니다. 최종적으로 아래와 같이
              3개의 VM 이 보이면 됩니다.
            </p>
            <p>
              <img src="/kubernetes/img/vbox-overall.png" alt="vbox-overall" />
            </p>
            <p>
              복제된 vm 에 접속하여 /etc/netplan/00-installer-config.yaml 파일을
              수정 합니다.
            </p>
            <pre><code class="language-{txt}">network:
  ethernets:
    enp0s3:
      dhcp4: no
      addresses: [10.0.2.17/24]  ## IP 수정 (VM 마다 하나씩 IP 증가)
      gateway4: 10.0.2.2
      nameservers:
              addresses: [8.8.8.8, 8.8.4.4]
    enp0s8:
      dhcp4: no
      addresses: [192.168.56.110/24] ## IP 수정 (VM 마다 하나씩 IP 증가)
  version: 2
</code></pre>
            <p>수정 후에는 netplan 명령어로 변경된 IP 로 적용</p>
            <pre><code class="language-{bash}">netplan apply
</code></pre>
            <h2 id="appendix-1-쿠버네티스-설치">Appendix 1. 쿠버네티스 설치</h2>
            <h3 id="1설치-사전-작업">1.설치 사전 작업</h3>
            <h4 id="11-nftable-disable">1.1 Nftable disable</h4>
            <pre><code class="language-{bash}">sudo update-alternatives --set iptables /usr/sbin/iptables-legacy
sudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy
sudo update-alternatives --set arptables /usr/sbin/arptables-legacy
sudo update-alternatives --set ebtables /usr/sbin/ebtables-legacy
</code></pre>
            <h4 id="12-호스트명-변경">1.2 호스트명 변경</h4>
            <pre><code class="language-{bash}"># hostnamectl set-hostname [FQDN-HOST-NAME] --static
# 마스터 노드에서 수행
hostnamectl set-hostname kmaster
hostnamectl set-hostname kmaster.acorn.com --static


# 첫번째 Worker 노드에서 수행
hostnamectl set-hostname kworker01
hostnamectl set-hostname kworker01.acorn.com --static

# 두번째 Worker 노드에서 수행
hostnamectl set-hostname kworker02
hostnamectl set-hostname kworker02.acorn.com --static
</code></pre>
            <h4 id="13-각노드에-호스트-파일-등록">
              1.3 각노드에 호스트 파일 등록
            </h4>
            <p>모든노드의 /etc/hosts 파일에 아래와 같이 등록 되어 있을것</p>
            <pre><code class="language-{bash}">192.168.56.111 kmaster.acorn.com kmaster
192.168.56.112 kworker01.acorn.com kworker01
192.168.56.113 kworker02.acorn.com kworker02
</code></pre>
            <h4 id="14-방화벽-점검">1.4 방화벽 점검</h4>
            <h5 id="141-control-plane-노드">1.4.1 Control Plane 노드</h5>
            <table>
              <thead>
                <tr>
                  <th style="text-align: left">Protocol</th>
                  <th style="text-align: left">Direction</th>
                  <th style="text-align: left">Port Range</th>
                  <th style="text-align: left">Purpose</th>
                  <th style="text-align: left">Used By</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td style="text-align: left">TCP</td>
                  <td style="text-align: left">Inbound</td>
                  <td style="text-align: left">6443*</td>
                  <td style="text-align: left">Kubernetes API server</td>
                  <td style="text-align: left">All</td>
                </tr>
                <tr>
                  <td style="text-align: left">TCP</td>
                  <td style="text-align: left">Inbound</td>
                  <td style="text-align: left">2379-2380</td>
                  <td style="text-align: left">etcd server client API</td>
                  <td style="text-align: left">kube-apiserver, etcd</td>
                </tr>
                <tr>
                  <td style="text-align: left">TCP</td>
                  <td style="text-align: left">Inbound</td>
                  <td style="text-align: left">10250</td>
                  <td style="text-align: left">Kubelet API</td>
                  <td style="text-align: left">Self, Control plane</td>
                </tr>
                <tr>
                  <td style="text-align: left">TCP</td>
                  <td style="text-align: left">Inbound</td>
                  <td style="text-align: left">10251</td>
                  <td style="text-align: left">kube-scheduler</td>
                  <td style="text-align: left">Self</td>
                </tr>
                <tr>
                  <td style="text-align: left">TCP</td>
                  <td style="text-align: left">Inbound</td>
                  <td style="text-align: left">10252</td>
                  <td style="text-align: left">kube-controller-manager</td>
                  <td style="text-align: left">Self</td>
                </tr>
              </tbody>
            </table>
            <h5 id="142-worker-노드">1.4.2 worker 노드</h5>
            <table>
              <thead>
                <tr>
                  <th style="text-align: left">Protocol</th>
                  <th style="text-align: left">Direction</th>
                  <th style="text-align: left">Port Range</th>
                  <th style="text-align: left">Purpose</th>
                  <th style="text-align: left">Used By</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td style="text-align: left">TCP</td>
                  <td style="text-align: left">Inbound</td>
                  <td style="text-align: left">10250</td>
                  <td style="text-align: left">Kubelet API</td>
                  <td style="text-align: left">Self, Control plane</td>
                </tr>
                <tr>
                  <td style="text-align: left">TCP</td>
                  <td style="text-align: left">Inbound</td>
                  <td style="text-align: left">30000-32767</td>
                  <td style="text-align: left">NodePort Services**</td>
                  <td style="text-align: left">All</td>
                </tr>
              </tbody>
            </table>
            <h3 id="2-runtime-설치">2. Runtime 설치</h3>
            <h4 id="21-도커-설치-all-nodes">2.1 도커 설치 (all nodes)</h4>
            <pre><code class="language-{bash}">sudo apt update
sudo apt install docker.io
</code></pre>
            <h4 id="22-kubernetes-설치-all-nodes">
              2.2 kubernetes 설치 (all nodes)
            </h4>
            <p>
              설치 스크립트
              <a
                href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#before-you-begin"
                >클릭</a
              >
            </p>
            <pre><code class="language-{bash}">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb https://apt.kubernetes.io/ kubernetes-xenial main
EOF
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre>
            <h3 id="3-post-installation">3. Post Installation</h3>
            <h4 id="31-swap-기능-해제all-nodes">
              3.1 SWAP 기능 해제(all nodes)
            </h4>
            <pre><code class="language-{bash}">sudo swapoff -a # 현재 일시적용
sudo sed -i '/swap/s/^/#/' /etc/fstab # 재가동 후에도 swapoff 할려면 수행 해야함
</code></pre>
            <h4 id="32-도커-시스템서비스-등록-하기-all-nodes">
              3.2 도커 시스템서비스 등록 하기 (all nodes)
            </h4>
            <p>
              도커 데몬을 system 서비스에 등록하지 않으면 kubernetes 설치시에
              warning 발생 하기 때문에 아래와 같이 등록해줌
            </p>
            <pre><code class="language-{bash}">sudo vi /etc/docker/daemon.json
</code></pre>
            <p>아래와 같이 입력 후 저장 합니다.</p>
            <pre><code class="language-{json}">{
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m"
  },
  "storage-driver": "overlay2"
}
</code></pre>
            <pre><code class="language-{bash}">
sudo mkdir -p /etc/systemd/system/docker.service.d

# Restart docker.
sudo systemctl enable docker.service
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
            <h4 id="33-kubeadm을-사용하여-마스터-설정-master-node">
              3.3 kubeadm을 사용하여 마스터 설정 (master node)
            </h4>
            <p>
              네트워크 인터페이스가 여러개일 경우 가장 우선 순위가 가장 높은
              인터페이스가 자동 선정 되기 때문에 ‘–apiserver-advertise-address'
              옵션을 사용해서 ip 혹은 인터페이스 명을 지정해야 합니다.
            </p>
            <pre><code class="language-{bash}">sudo kubeadm init --pod-network-cidr=192.168.0.0/16 --service-cidr 10.96.0.0/12  --apiserver-advertise-address=192.168.56.111

# kubeadmin init 시에 여러 가지 옵션들
# --pod-network-cidr=192.168.0.0/16
# --control-plane-endpoint=192.168.56.111
# --apiserver-cert-extra-sans=192.168.56.111
# --service-cidr 10.96.0.0/12
# --service-dns-domain "k8s"
# --apiserver-advertise-address __YOUR_IP_HERE___

# 잘못 설치한 경우 master 및 worker 노드에 수행 하면 모든 설정을 초기화함
# kubeadm reset cleanup-node
</code></pre>
            <h3 id="4-워커-노드-등록">4. 워커 노드 등록</h3>
            <h4 id="41-워커-노드-등록-worker-node-only">
              4.1 워커 노드 등록 (worker node only)
            </h4>
            <blockquote>
              <p>
                반듯이 kubeadm init 을 통해 나온 로그에 표시된 ip 와 token 으로
                worker 노드에서만 수행
              </p>
            </blockquote>
            <pre><code class="language-{bash}">sudo kubeadm join 192.168.56.111:6443 --token dro5or.x9ujk49k0aadiz8s \
    --discovery-token-ca-cert-hash sha256:b6372f30c5733a5c88d0a6b6095efbf4cb495329cbcd19df33e7a894a96ec53d
</code></pre>
            <h4 id="42-마스터-노드-kube-client-설정-master-node">
              4.2 마스터 노드 kube client 설정 (master node)
            </h4>
            <pre><code class="language-{bash}">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
            <h4 id="43-클러스터-상태-확인master-node">
              4.3 클러스터 상태 확인(master node)
            </h4>
            <p>결과가 모두 not ready 로 나옴 (시간이 좀 걸림)</p>
            <pre><code class="language-{bash}">kubectl get nodes
</code></pre>
            <h4 id="44-네트워크-어플리케이션-설치master-node">
              4.4 네트워크 어플리케이션 설치(master node)
            </h4>
            <p>네트워크 툴 설치 후에는 모든 노드가 ready 로 나와야 함</p>
            <pre><code class="language-{bash}">kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"

kubectl get nodes
</code></pre>
            <h4 id="45-kubectl-명령어-자동완성-패키지-설치master-node">
              4.5 kubectl 명령어 자동완성 패키지 설치(master node)
            </h4>
            <pre><code class="language-{bash}"># 자동 완성을 bash 셸에 영구적으로 추가한다
echo "# k8s auto completion and alias" &gt;&gt; ~/.bashrc
echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc
echo "alias k=kubectl"  &gt;&gt; ~/.bashrc
echo "complete -F __start_kubectl k" &gt;&gt; ~/.bashrc
</code></pre>
            <h3 id="5-etcd-설치master-node">5. etcd 설치(master node)</h3>
            <p>
              기본적으로 내장 etcd 가 있지만, etcd-io 의 릴리즈로 설치 합니다.
            </p>
            <p>
              다운로드 url :
              <a href="https://github.com/etcd-io/etcd/releases">클릭</a>
            </p>
            <pre><code class="language-{bash}">wget https://github.com/etcd-io/etcd/releases/download/v3.3.18/etcd-v3.3.18-linux-amd64.tar.gz
tar -xf etcd-v3.3.18-linux-amd64.tar.gz
cd etcd-v3.3.18-linux-amd64

sudo ETCDCTL_API=3 ./etcdctl --endpoints 127.0.0.1:2379 \
--cacert /etc/kubernetes/pki/etcd/ca.crt \
--cert /etc/kubernetes/pki/etcd/server.crt \
--key /etc/kubernetes/pki/etcd/server.key \
get / --prefix --keys-only
</code></pre>
            <h2 id="appendix-2-구글-gke-사용하기">
              Appendix 2. 구글 GKE 사용하기
            </h2>
            <h4 id="1-회원가입">1. 회원가입</h4>
            <ul>
              <li>$300 무료 크레딧 제공</li>
              <li>신용카드 필요 (한도를 넘으도 자동 과금 안됨)</li>
              <li>http://cloud.google.com 에서 회원 가입</li>
            </ul>
            <h4 id="2-프로젝트-생성">2. 프로젝트 생성</h4>
            <ul>
              <li><kbd>프로젝트 선택</kbd> 을 클릭 합니다.</li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-project-int.png"
                alt="프로젝트 선택"
              />
            </p>
            <ul>
              <li><kbd>새 프로젝트</kbd> 를 클릭 합니다.</li>
            </ul>
            <p><img src="/kubernetes/img/GKE-project-choose.png" alt="" /></p>
            <ul>
              <li>
                프로젝트 이름에 원하는 값을 입력하고 <kbd>만들기</kbd> 클릭
              </li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-new-project.png"
                alt="GKE-new-project"
              />
            </p>
            <h4 id="3-쿠버네티스-클러스터-생성">3. 쿠버네티스 클러스터 생성</h4>
            <ul>
              <li>홈메뉴 에서 <kbd> Kubernetes Engine </kbd> 클릭</li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-ngine-enter.png"
                alt="GKE-ngine-enter"
              />
            </p>
            <ul>
              <li>프로젝트를 선택하기 위해 <kbd> 프로젝트 선택</kbd> 클릭</li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-choose-project-for-create-cluster.png"
                alt="GKE-choose-project-for-create-cluster"
              />
            </p>
            <ul>
              <li>
                팝업창이 뜨면 프로젝트 gke-first 를 선택하고
                <kbd> 열기 </kbd> 클릭
              </li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-open-project.png"
                alt="GKE-open-project"
              />
            </p>
            <ul>
              <li>1분정도 기다린 후에 <kbd> 클러스터 만들기 </kbd> 클릭</li>
            </ul>
            <p><img src="/kubernetes/img/GKE-create-cluster.png" alt="" /></p>
            <ul>
              <li>
                클러스터 기본사항 에서 영역을 "asia-east1-a" 로 선택 한후,
                <kbd> 만들기</kbd> 클릭
              </li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-create-cluster-1.png"
                alt="GKE-create-cluster-1"
              />
            </p>
            <ul>
              <li>
                아래와 같이 k8s 클러스터를 생성 중인 화면이 나오면 정상 적으로
                진행이 된 것입니다.
              </li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-cluster-complete.png"
                alt="GKE-cluster-complete"
              />
            </p>
            <h4 id="4-쿠버네티스-클러스터-접속-테스트">
              4. 쿠버네티스 클러스터 접속 테스트
            </h4>
            <ul>
              <li>GKE 클러스터가 생성되면 <kbd> 연결 </kbd> 클릭</li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-cluster-connect-1.png"
                alt="GKE-cluster-connect-1"
              />
            </p>
            <ul>
              <li>팝업창이 뜨면 <kbd> Cloud Shell에서 실행 </kbd> 클릭</li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/GKE-cluster-connect-2.png"
                alt="GKE-cluster-connect-2"
              />
            </p>
            <h2 id="appendix-4-google-cloud-sdk-설치-하기">
              Appendix 4. Google Cloud SDK 설치 하기
            </h2>
            <h3 id="1-gcloud-sdk-다운로드">1. GCloud SDK 다운로드</h3>
            <p>
              <img src="/kubernetes/img/cloud_sdk_1.png" alt="cloud_sdk_1" />
            </p>
            <h3 id="2-cloud-sdk-설치">2. Cloud SDK 설치</h3>
            <p>
              <img src="/kubernetes/img/cloud_sdk_2.png" alt="cloud_sdk_2" />
            </p>
            <h3 id="3-로컬-머신에서-cloud-shell-연결-명령어-복사">
              3. 로컬 머신에서 Cloud Shell 연결 명령어 복사
            </h3>
            <p><img src="../img/cloud_sdk_3.png" alt="" /></p>
            <p>
              <img src="/kubernetes/img/cloud_sdk_4.png" alt="cloud_sdk_4" />
            </p>
            <h3 id="4-로컬-cmd-또는-shell-에서-연결-하기">
              4. 로컬 CMD 또는 SHELL 에서 연결 하기
            </h3>
            <p>웹에서 복사한 내용을 그대로 붙여놓고 실행</p>
            <p>
              <img src="/kubernetes/img/cloud_sdk_5.png" alt="cloud_sdk_5" />
            </p>
            <h2 id="appendix-3-git-계정-생성-및-sync">
              Appendix 3. Git 계정 생성 및 Sync
            </h2>
            <h3 id="1git-계정생성">1.Git 계정생성</h3>
            <p>www.github.com 에서 계정 생성</p>
            <h3 id="2-git-리포지토리-생성">2. Git 리포지토리 생성</h3>
            <ul>
              <li>
                GitHub.com 에 자신의 계정으로 로그인하여 아래 화면과 같이
                리포지토리 생성
              </li>
            </ul>
            <p><img src="/kubernetes/img/git_repo_create.png" alt="" /></p>
            <ul>
              <li>
                리포지토리 이름을 아래와 같이 입력하고. 생성 합니다. (Repository
                name : k8s-web)
              </li>
            </ul>
            <p>
              <img
                src="/kubernetes/img/git_repo_create_spec.png"
                alt="git_repo_create_spec"
              />
            </p>
            <h3 id="3-소스-파일-작성">3. 소스 파일 작성</h3>
            <pre><code class="language-{bash}">$ mkdir -p ./gitvolumn/html
$ mkdir -p ./gitvolumn/kubetmp
$ cd ./gitvolumn/html
$ vi index.html
</code></pre>
            <p>index.html 이름으로 아래 페이지를 작성 합니다.</p>
            <pre><code class="language-{html}">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;K8s Landing Page&lt;/h1&gt;

&lt;p&gt;Hello Kubernetes !!!&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;

</code></pre>
            <h3 id="4-git-리포지토리-생성-및-초기화">
              4. Git 리포지토리 생성 및 초기화
            </h3>
            <pre><code class="language-{bash}">$ git init
$ git add .
$ git commit -a -m "first commit"

$ git remote add origin https://github.com/&lt;계정명&gt;/k8s-web.git
$ git remote -v
$ git push origin master

$ git status

</code></pre>
            <h2 id="appendix-4-persist-volume-서비스를-위한-ceph-설치">
              Appendix 4. Persist Volume 서비스를 위한 Ceph 설치
            </h2>
            <h3 id="1-ceph-설치worker01-worker02">
              1. Ceph 설치(worker01, worker02)
            </h3>
            <pre><code class="language-{bash}">$ apt-cache search ceph

$ apt install ceph


</code></pre>
          </div>
        </div>
        <hr />
        <div class="copyright text-center text-gray" role="contentinfo">
          <i class="fa fa-copyright"></i> <span class="time">2021,</span>
          <a
            class="text-gray"
            href="https://github.com/dangtong76"
            rel="noreferrer"
            target="_blank"
            >dangtong76</a
          >
          Revision
          <a
            class="text-gray"
            href="https://github.com/dangtong76/dangtong76.github.io/commit/ff840bb3691476618fd914e6d360a95225fca8fe"
            title="ff840bb3691476618fd914e6d360a95225fca8fe"
            rel="noreferrer"
            target="_blank"
            >ff840bb</a
          >
          <br />
          <div class="generator">
            Built with
            <a
              href="https://pages.github.com"
              rel="noreferrer"
              target="_blank"
              title="github-pages v209"
              >GitHub Pages</a
            >
            using a
            <a
              href="https://github.com/rundocs/jekyll-rtd-theme"
              rel="noreferrer"
              target="_blank"
              title="jekyll-rtd-theme v2.0.10"
              >theme</a
            >
            provided by
            <a href="https://rundocs.io" rel="noreferrer" target="_blank"
              >RunDocs</a
            >.
          </div>
        </div>
      </div>
    </div>
    <div class="addons-wrap d-flex flex-column overflow-y-auto">
      <div class="status d-flex flex-justify-between p-2">
        <div class="title p-1"><i class="fa fa-book"></i> 당통의 블로그</div>
        <div class="branch p-1">
          <span class="name"> gh-pages </span> <i class="fa fa-caret-down"></i>
        </div>
      </div>
      <div class="addons d-flex flex-column height-full p-2 d-none">
        <dl>
          <dt>GitHub</dt>
          <dd>
            <a
              href="https://github.com/dangtong76/dangtong76.github.io"
              title="Stars: 0"
            >
              <i class="fa fa-github"></i> Homepage
            </a>
          </dd>
          <dd>
            <a
              href="https://github.com/dangtong76/dangtong76.github.io/issues"
              title="Open issues: 0"
            >
              <i class="fa fa-question-circle-o"></i> Issues
            </a>
          </dd>
          <dd>
            <a
              href="https://github.com/dangtong76/dangtong76.github.io/zipball/gh-pages"
              title="Size: 379672 Kb"
            >
              <i class="fa fa-download"></i> Download
            </a>
          </dd>
        </dl>
        <hr />
        <div class="license f6 pb-2">
          This <a href="/" title="당통의 블로그">Software</a> is under the terms
          of
          <a href="https://github.com/dangtong76/dangtong76.github.io"
            >MIT License</a
          >.
        </div>
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/gh/rundocs/jekyll-rtd-theme@2.0.10/assets/js/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/rundocs/jekyll-rtd-theme@2.0.10/assets/js/theme.min.js"></script>
  </body>
</html>
